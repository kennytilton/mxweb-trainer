["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/html/sanitizer/safedomtreeprocessor.js"],"~:js","goog.loadModule(function(exports) {\n  \"use strict\";\n  goog.module(\"goog.html.sanitizer.SafeDomTreeProcessor\");\n  goog.module.declareLegacyNamespace();\n  var Const = goog.require(\"goog.string.Const\");\n  var ElementWeakMap = goog.require(\"goog.html.sanitizer.ElementWeakMap\");\n  var Logger = goog.require(\"goog.log.Logger\");\n  var NodeType = goog.require(\"goog.dom.NodeType\");\n  var TagName = goog.require(\"goog.dom.TagName\");\n  var googDom = goog.require(\"goog.dom\");\n  var googLog = goog.require(\"goog.log\");\n  var noclobber = goog.require(\"goog.html.sanitizer.noclobber\");\n  var safe = goog.require(\"goog.dom.safe\");\n  var uncheckedconversions = goog.require(\"goog.html.uncheckedconversions\");\n  var userAgent = goog.require(\"goog.userAgent\");\n  var logger = googLog.getLogger(\"goog.html.sanitizer.SafeDomTreeProcessor\");\n  var SAFE_PARSING_SUPPORTED = !userAgent.IE || userAgent.isDocumentModeOrHigher(10);\n  var HTML_SANITIZER_TEMPLATE_SUPPORTED = !userAgent.IE || document.documentMode == null;\n  function getDomTreeWalker(html) {\n    var iteratorParent;\n    var safeHtml = uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(Const.from(\"Never attached to DOM.\"), html);\n    var templateElement = document.createElement(\"template\");\n    if (HTML_SANITIZER_TEMPLATE_SUPPORTED && \"content\" in templateElement) {\n      safe.unsafeSetInnerHtmlDoNotUseOrElse(templateElement, safeHtml);\n      iteratorParent = templateElement.content;\n    } else {\n      var doc = document.implementation.createHTMLDocument(\"x\");\n      iteratorParent = doc.body;\n      safe.unsafeSetInnerHtmlDoNotUseOrElse(doc.body, safeHtml);\n    }\n    return document.createTreeWalker(iteratorParent, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);\n  }\n  var SafeDomTreeProcessor = function() {\n  };\n  SafeDomTreeProcessor.prototype.processToString = function(html) {\n    if (!SAFE_PARSING_SUPPORTED) {\n      return \"\";\n    }\n    var newTree = this.processToTree(html);\n    if (noclobber.getElementAttributes(newTree).length > 0) {\n      var newRoot = googDom.createElement(TagName.SPAN);\n      newRoot.appendChild(newTree);\n      newTree = newRoot;\n    }\n    var serializedNewTree = (new XMLSerializer()).serializeToString(newTree);\n    return serializedNewTree.slice(serializedNewTree.indexOf(\"\\x3e\") + 1, serializedNewTree.lastIndexOf(\"\\x3c/\"));\n  };\n  SafeDomTreeProcessor.prototype.processToTree = function(html) {\n    if (!SAFE_PARSING_SUPPORTED) {\n      return googDom.createElement(TagName.SPAN);\n    }\n    var newRoot = googDom.createElement(TagName.SPAN);\n    this.processRoot(newRoot);\n    html = this.preProcessHtml(html);\n    var originalTreeWalker = getDomTreeWalker(html);\n    var elementMap = ElementWeakMap.newWeakMap();\n    var originalNode;\n    while (originalNode = originalTreeWalker.nextNode()) {\n      var newNode = this.createNode_(originalNode);\n      if (!newNode) {\n        googDom.removeChildren(originalNode);\n        continue;\n      }\n      if (noclobber.isNodeElement(newNode)) {\n        elementMap.set(originalNode, newNode);\n      }\n      var originalParent = noclobber.getParentNode(originalNode);\n      var isParentRoot = false;\n      if (originalParent) {\n        var originalParentNodeType = noclobber.getNodeType(originalParent);\n        var originalParentNodeName = noclobber.getNodeName(originalParent).toLowerCase();\n        var originalGrandParent = noclobber.getParentNode(originalParent);\n        if (originalParentNodeType == NodeType.DOCUMENT_FRAGMENT && !originalGrandParent) {\n          isParentRoot = true;\n        } else if (originalParentNodeName == \"body\" && originalGrandParent) {\n          var dirtyGreatGrandParent = noclobber.getParentNode(originalGrandParent);\n          if (dirtyGreatGrandParent && !noclobber.getParentNode(dirtyGreatGrandParent)) {\n            isParentRoot = true;\n          }\n        }\n        var newParent = null;\n        if (isParentRoot || !originalParent) {\n          newParent = newRoot;\n        } else if (noclobber.isNodeElement(originalParent)) {\n          newParent = elementMap.get(originalParent);\n        }\n        if (newParent.content) {\n          newParent = newParent.content;\n        }\n        newParent.appendChild(newNode);\n      }\n    }\n    if (elementMap.clear) {\n      elementMap.clear();\n    }\n    return newRoot;\n  };\n  SafeDomTreeProcessor.prototype.processRoot = function(newRoot) {\n  };\n  SafeDomTreeProcessor.prototype.preProcessHtml = function(html) {\n  };\n  SafeDomTreeProcessor.prototype.createNode_ = function(originalNode) {\n    var nodeType = noclobber.getNodeType(originalNode);\n    switch(nodeType) {\n      case NodeType.TEXT:\n        return this.createTextNode(originalNode);\n      case NodeType.ELEMENT:\n        return this.createElement_(noclobber.assertNodeIsElement(originalNode));\n      default:\n        googLog.warning(logger, \"Dropping unknown node type: \" + nodeType);\n        return null;\n    }\n  };\n  SafeDomTreeProcessor.prototype.createTextNode = function(originalNode) {\n  };\n  SafeDomTreeProcessor.prototype.createElement_ = function(originalElement) {\n    if (noclobber.getNodeName(originalElement).toUpperCase() == \"TEMPLATE\") {\n      return null;\n    }\n    var newElement = this.createElementWithoutAttributes(originalElement);\n    if (!newElement) {\n      return null;\n    }\n    this.processElementAttributes_(originalElement, newElement);\n    return newElement;\n  };\n  SafeDomTreeProcessor.prototype.createElementWithoutAttributes = function(originalElement) {\n  };\n  SafeDomTreeProcessor.prototype.processElementAttributes_ = function(originalElement, newElement) {\n    var attributes = noclobber.getElementAttributes(originalElement);\n    if (attributes == null) {\n      return;\n    }\n    for (var i = 0, attribute; attribute = attributes[i]; i++) {\n      if (attribute.specified) {\n        var newValue = this.processElementAttribute(originalElement, attribute);\n        if (newValue !== null) {\n          noclobber.setElementAttribute(newElement, attribute.name, newValue);\n        }\n      }\n    }\n  };\n  SafeDomTreeProcessor.prototype.processElementAttribute = function(element, attribute) {\n  };\n  SafeDomTreeProcessor.SAFE_PARSING_SUPPORTED = SAFE_PARSING_SUPPORTED;\n  exports = SafeDomTreeProcessor;\n  return exports;\n});\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n/**\n * @fileoverview A base class to safely parse and transform an HTML string\n * using an inert DOM, which avoids executing scripts and loading images. Note:\n * this class does *not* guarantee that the output does not contain scripts and\n * images that eventually execute once the output is inserted into an active DOM\n * document. If any subclass claims to produce SafeHtml output, it must be\n * reviewed separately.\n * @supported IE 10+, Chrome 26+, Firefox 22+, Safari 7.1+, Opera 15+\n */\n\ngoog.module('goog.html.sanitizer.SafeDomTreeProcessor');\ngoog.module.declareLegacyNamespace();\n\nvar Const = goog.require('goog.string.Const');\nvar ElementWeakMap = goog.require('goog.html.sanitizer.ElementWeakMap');\nvar Logger = goog.require('goog.log.Logger');\nvar NodeType = goog.require('goog.dom.NodeType');\nvar TagName = goog.require('goog.dom.TagName');\nvar googDom = goog.require('goog.dom');\nvar googLog = goog.require('goog.log');\nvar noclobber = goog.require('goog.html.sanitizer.noclobber');\nvar safe = goog.require('goog.dom.safe');\nvar uncheckedconversions = goog.require('goog.html.uncheckedconversions');\nvar userAgent = goog.require('goog.userAgent');\n\n/** @const {?Logger} */\nvar logger = googLog.getLogger('goog.html.sanitizer.SafeDomTreeProcessor');\n\n/**\n * Whether the HTML sanitizer is supported. For now mainly exclude\n * IE9 or below, for which we know the sanitizer is insecure or broken.\n * @const {boolean}\n */\nvar SAFE_PARSING_SUPPORTED =\n    !userAgent.IE || userAgent.isDocumentModeOrHigher(10);\n\n/**\n * Whether the template tag is supported.\n * @const {boolean}\n */\nvar HTML_SANITIZER_TEMPLATE_SUPPORTED =\n    !userAgent.IE || document.documentMode == null;\n\n/**\n * Parses a string of unsanitized HTML and provides an iterator over the\n * resulting DOM tree nodes. The parsing operation is inert (that is,\n * it does not cause execution of any active content or cause the browser to\n * issue any requests). The returned iterator is guaranteed to iterate over a\n * parent element before iterating over any of its children.\n * @param {string} html\n * @return {!TreeWalker}\n */\nfunction getDomTreeWalker(html) {\n  var iteratorParent;\n  var safeHtml =\n      uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(\n          Const.from('Never attached to DOM.'), html);\n  var templateElement = document.createElement('template');\n  if (HTML_SANITIZER_TEMPLATE_SUPPORTED && 'content' in templateElement) {\n    safe.unsafeSetInnerHtmlDoNotUseOrElse(templateElement, safeHtml);\n    iteratorParent = templateElement.content;\n  } else {\n    // In browsers where <template> is not implemented, use an inert\n    // HTMLDocument.\n    var doc = document.implementation.createHTMLDocument('x');\n    iteratorParent = doc.body;\n    safe.unsafeSetInnerHtmlDoNotUseOrElse(doc.body, safeHtml);\n  }\n  return document.createTreeWalker(\n      iteratorParent, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,\n      null /* filter */, false /* entityReferenceExpansion */);\n}\n\n/**\n * Constructs a {@link SafeDomTreeProcessor} object that safely parses an input\n * string into a DOM tree using an inert document, and creates a new tree based\n * on the original tree, optionally transforming it in the process. The\n * transformation is not specified in this abstract class; subclasses are\n * supposed to override its protected methods to define a transformation that\n * allows tags and attributes, drops entire subtrees, modifies tag names or\n * attributes, etc.\n * @constructor @struct @abstract\n */\nvar SafeDomTreeProcessor = function() {};\n\n/**\n * Parses an HTML string and walks the resulting DOM forest to apply the\n * transformation function and generate a new forest. Returns the string\n * representation of the forest.\n * @param {string} html\n * @return {string}\n * @protected @final\n */\nSafeDomTreeProcessor.prototype.processToString = function(html) {\n  if (!SAFE_PARSING_SUPPORTED) {\n    return '';\n  }\n\n  var newTree = this.processToTree(html);\n  if (noclobber.getElementAttributes(newTree).length > 0) {\n    // We want to preserve the outer SPAN tag, because the processor has\n    // attached attributes to it. To do so, we make a new SPAN tag the parent of\n    // the existing root span tag, so that the rest of the function will remove\n    // that one instead.\n    var newRoot = googDom.createElement(TagName.SPAN);\n    newRoot.appendChild(newTree);\n    newTree = newRoot;\n  }\n  // The XMLSerializer will add a spurious xmlns attribute to the root node.\n  var serializedNewTree = new XMLSerializer().serializeToString(newTree);\n  // Remove the outer span before returning the string representation of the\n  // processed copy.\n  return serializedNewTree.slice(\n      serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\n};\n\n/**\n * Parses an HTML string and walks the resulting DOM forest to apply the\n * transformation function and generate a copy of the forest. Returns the forest\n * wrapped in a common SPAN parent, so that the result is always a tree.\n * @param {string} html\n * @return {!HTMLSpanElement}\n * @protected @final\n */\nSafeDomTreeProcessor.prototype.processToTree = function(html) {\n  if (!SAFE_PARSING_SUPPORTED) {\n    return googDom.createElement(TagName.SPAN);\n  }\n  var newRoot = googDom.createElement(TagName.SPAN);\n  // Allow subclasses to attach properties to the root.\n  this.processRoot(newRoot);\n\n  // Allow subclasses to pre-process the HTML string before performing the main\n  // tree-based transformation.\n  html = this.preProcessHtml(html);\n  var originalTreeWalker = getDomTreeWalker(html);\n\n  // Mapping from original nodes to new nodes, used to find the parent to which\n  // a newly processed node should be attached.\n  var elementMap = ElementWeakMap.newWeakMap();\n\n  var originalNode;\n  while (originalNode = originalTreeWalker.nextNode()) {\n    // Make a copy of the node, potentially dropping it or changing its content,\n    // tag name, etc.\n    var newNode = this.createNode_(originalNode);\n    if (!newNode) {\n      // The transformation function chose not to copy over the node. We delete\n      // the children so that the current treeWalker will stop iterating on\n      // them.\n      googDom.removeChildren(originalNode);\n      continue;\n    }\n    if (noclobber.isNodeElement(newNode)) {\n      elementMap.set(originalNode, newNode);\n    }\n\n    // Finds the new parent to which newNode should be appended. The tree is\n    // copied top-down, so the parent of the current node has already been\n    // copied and placed into the new tree. The new parent is either the root\n    // of the new tree or a node found using originalToNewElementMap.\n    var originalParent = noclobber.getParentNode(originalNode);\n    var isParentRoot = false;\n    if (originalParent) {\n      var originalParentNodeType = noclobber.getNodeType(originalParent);\n      var originalParentNodeName =\n          noclobber.getNodeName(originalParent).toLowerCase();\n      var originalGrandParent = noclobber.getParentNode(originalParent);\n      // The following checks if newParent is an immediate child of the inert\n      // parent template element.\n      if (originalParentNodeType == NodeType.DOCUMENT_FRAGMENT &&\n          !originalGrandParent) {\n        isParentRoot = true;\n      } else if (originalParentNodeName == 'body' && originalGrandParent) {\n        // The following checks if newParent is an immediate child of the\n        // inert parent HtmlDocument.\n        var dirtyGreatGrandParent =\n            noclobber.getParentNode(originalGrandParent);\n        if (dirtyGreatGrandParent &&\n            !noclobber.getParentNode(dirtyGreatGrandParent)) {\n          isParentRoot = true;\n        }\n      }\n      var newParent = null;\n      if (isParentRoot || !originalParent) {\n        newParent = newRoot;\n      } else if (noclobber.isNodeElement(originalParent)) {\n        newParent = elementMap.get(originalParent);\n      }\n      if (newParent.content) {\n        newParent = newParent.content;\n      }\n      newParent.appendChild(newNode);\n    }\n  }\n  if (elementMap.clear) {\n    // Clear the map. On browsers that don't support WeakMap, entries are not\n    // automatically cleaned up.\n    elementMap.clear();\n  }\n  return newRoot;\n};\n\n/**\n * Creates the root SPAN element for the new tree. This function can be\n * overridden to add attributes to the tag. Note that if any attributes are\n * added to the element, then {@link processToString} will not strip it from the\n * generated string to preserve the attributes.\n * @param {!HTMLSpanElement} newRoot\n * @protected @abstract\n */\nSafeDomTreeProcessor.prototype.processRoot = function(newRoot) {};\n\n/**\n * Pre-processes the input html before the main tree-based transformation.\n * @param {string} html\n * @return {string}\n * @protected @abstract\n */\nSafeDomTreeProcessor.prototype.preProcessHtml = function(html) {};\n\n/**\n * Returns a new node based on the transformation of an original node, or null\n * if the node and all its children should not be copied over to the new tree.\n * @param {!Node} originalNode\n * @return {?Node}\n * @private\n */\nSafeDomTreeProcessor.prototype.createNode_ = function(originalNode) {\n  var nodeType = noclobber.getNodeType(originalNode);\n  switch (nodeType) {\n    case NodeType.TEXT:\n      return this.createTextNode(/** @type {!Text} */ (originalNode));\n    case NodeType.ELEMENT:\n      return this.createElement_(noclobber.assertNodeIsElement(originalNode));\n    default:\n      googLog.warning(logger, 'Dropping unknown node type: ' + nodeType);\n      return null;\n  }\n};\n\n/**\n * Creates a new text node from the original text node, or null if the node\n * should not be copied over to the new tree.\n * @param {!Text} originalNode\n * @return {?Text}\n * @protected @abstract\n */\nSafeDomTreeProcessor.prototype.createTextNode = function(originalNode) {};\n\n/**\n * Creates a new element from the original element, potentially applying\n * transformations to the element's tagname and attributes.\n * @param {!Element} originalElement\n * @return {?Element}\n * @private\n */\nSafeDomTreeProcessor.prototype.createElement_ = function(originalElement) {\n  if (noclobber.getNodeName(originalElement).toUpperCase() == 'TEMPLATE') {\n    // Processing TEMPLATE tags is not supported, they are automatically\n    // dropped.\n    return null;\n  }\n  var newElement = this.createElementWithoutAttributes(originalElement);\n  if (!newElement) {\n    return null;\n  }\n  // Copy over element attributes, applying a transformation on each attribute.\n  this.processElementAttributes_(originalElement, newElement);\n  return newElement;\n};\n\n/**\n * Creates a new element from the original element. This function should only\n * either create a new element (optionally changing the tag name from the\n * original element) or return null to prevent the entire subtree from appearing\n * in the output. Note that TEMPLATE tags and their contents are automatically\n * dropped, and this function is not called to decide whether to keep them or\n * not.\n * @param {!Element} originalElement\n * @return {?Element}\n * @protected @abstract\n */\nSafeDomTreeProcessor.prototype.createElementWithoutAttributes = function(\n    originalElement) {};\n\n/**\n * Copies over the attributes of an original node to its corresponding new node\n * generated with {@link processNode}.\n * @param {!Element} originalElement\n * @param {!Element} newElement\n * @private\n */\nSafeDomTreeProcessor.prototype.processElementAttributes_ = function(\n    originalElement, newElement) {\n  var attributes = noclobber.getElementAttributes(originalElement);\n  if (attributes == null) {\n    return;\n  }\n  for (var i = 0, attribute; attribute = attributes[i]; i++) {\n    if (attribute.specified) {\n      var newValue = this.processElementAttribute(originalElement, attribute);\n      if (newValue !== null) {\n        noclobber.setElementAttribute(newElement, attribute.name, newValue);\n      }\n    }\n  }\n};\n\n/**\n * Returns the new value for an attribute, or null if the attribute should be\n * dropped.\n * @param {!Element} element\n * @param {!Attr} attribute\n * @return {?string}\n * @protected @abstract\n */\nSafeDomTreeProcessor.prototype.processElementAttribute = function(\n    element, attribute) {};\n\n/** @const {boolean} */\nSafeDomTreeProcessor.SAFE_PARSING_SUPPORTED = SAFE_PARSING_SUPPORTED;\nexports = SafeDomTreeProcessor;\n","~:compiled-at",1645592433431,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.html.sanitizer.safedomtreeprocessor.js\",\n\"lineCount\":149,\n\"mappings\":\"AAiBA,IAAA,CAAA,UAAA,CAAA,QAAA,CAAA,OAAA,CAAA;AAAA,cAAA;AAAAA,MAAKC,CAAAA,MAAL,CAAY,0CAAZ,CAAA;AACAD,MAAKC,CAAAA,MAAOC,CAAAA,sBAAZ,EAAA;AAEA,MAAIC,QAAQH,IAAKI,CAAAA,OAAL,CAAa,mBAAb,CAAZ;AACA,MAAIC,iBAAiBL,IAAKI,CAAAA,OAAL,CAAa,oCAAb,CAArB;AACA,MAAIE,SAASN,IAAKI,CAAAA,OAAL,CAAa,iBAAb,CAAb;AACA,MAAIG,WAAWP,IAAKI,CAAAA,OAAL,CAAa,mBAAb,CAAf;AACA,MAAII,UAAUR,IAAKI,CAAAA,OAAL,CAAa,kBAAb,CAAd;AACA,MAAIK,UAAUT,IAAKI,CAAAA,OAAL,CAAa,UAAb,CAAd;AACA,MAAIM,UAAUV,IAAKI,CAAAA,OAAL,CAAa,UAAb,CAAd;AACA,MAAIO,YAAYX,IAAKI,CAAAA,OAAL,CAAa,+BAAb,CAAhB;AACA,MAAIQ,OAAOZ,IAAKI,CAAAA,OAAL,CAAa,eAAb,CAAX;AACA,MAAIS,uBAAuBb,IAAKI,CAAAA,OAAL,CAAa,gCAAb,CAA3B;AACA,MAAIU,YAAYd,IAAKI,CAAAA,OAAL,CAAa,gBAAb,CAAhB;AAGA,MAAIW,SAASL,OAAQM,CAAAA,SAAR,CAAkB,0CAAlB,CAAb;AAOA,MAAIC,yBACA,CAACH,SAAUI,CAAAA,EADXD,IACiBH,SAAUK,CAAAA,sBAAV,CAAiC,EAAjC,CADrB;AAOA,MAAIC,oCACA,CAACN,SAAUI,CAAAA,EADXE,IACiBC,QAASC,CAAAA,YAD1BF,IAC0C,IAD9C;AAYAG,UAASA,iBAAgB,CAACC,IAAD,CAAO;AAC9B,QAAIC,cAAJ;AACA,QAAIC,WACAb,oBAAqBc,CAAAA,4CAArB,CACIxB,KAAMyB,CAAAA,IAAN,CAAW,wBAAX,CADJ,EAC0CJ,IAD1C,CADJ;AAGA,QAAIK,kBAAkBR,QAASS,CAAAA,aAAT,CAAuB,UAAvB,CAAtB;AACA,QAAIV,iCAAJ,IAAyC,SAAzC,IAAsDS,eAAtD,CAAuE;AACrEjB,UAAKmB,CAAAA,gCAAL,CAAsCF,eAAtC,EAAuDH,QAAvD,CAAA;AACAD,oBAAA,GAAiBI,eAAgBG,CAAAA,OAAjC;AAFqE,KAAvE,KAGO;AAGL,UAAIC,MAAMZ,QAASa,CAAAA,cAAeC,CAAAA,kBAAxB,CAA2C,GAA3C,CAAV;AACAV,oBAAA,GAAiBQ,GAAIG,CAAAA,IAArB;AACAxB,UAAKmB,CAAAA,gCAAL,CAAsCE,GAAIG,CAAAA,IAA1C,EAAgDV,QAAhD,CAAA;AALK;AAOP,WAAOL,QAASgB,CAAAA,gBAAT,CACHZ,cADG,EACaa,UAAWC,CAAAA,YADxB,GACuCD,UAAWE,CAAAA,SADlD,EAEH,IAFG,EAEgB,KAFhB,CAAP;AAhB8B;AA+BhC,MAAIC,uBAAuBA,QAAQ,EAAG;GAAtC;AAUAA,sBAAqBC,CAAAA,SAAUC,CAAAA,eAA/B,GAAiDC,QAAQ,CAACpB,IAAD,CAAO;AAC9D,QAAI,CAACP,sBAAL;AACE,aAAO,EAAP;AADF;AAIA,QAAI4B,UAAU,IAAKC,CAAAA,aAAL,CAAmBtB,IAAnB,CAAd;AACA,QAAIb,SAAUoC,CAAAA,oBAAV,CAA+BF,OAA/B,CAAwCG,CAAAA,MAA5C,GAAqD,CAArD,CAAwD;AAKtD,UAAIC,UAAUxC,OAAQqB,CAAAA,aAAR,CAAsBtB,OAAQ0C,CAAAA,IAA9B,CAAd;AACAD,aAAQE,CAAAA,WAAR,CAAoBN,OAApB,CAAA;AACAA,aAAA,GAAUI,OAAV;AAPsD;AAUxD,QAAIG,oBAAwCC,CAApB,IAAIC,aAAJ,EAAoBD,EAAAA,iBAApB,CAAsCR,OAAtC,CAAxB;AAGA,WAAOO,iBAAkBG,CAAAA,KAAlB,CACHH,iBAAkBI,CAAAA,OAAlB,CAA0B,MAA1B,CADG,GAC8B,CAD9B,EACiCJ,iBAAkBK,CAAAA,WAAlB,CAA8B,OAA9B,CADjC,CAAP;AAnB8D,GAAhE;AA+BAhB,sBAAqBC,CAAAA,SAAUI,CAAAA,aAA/B,GAA+CY,QAAQ,CAAClC,IAAD,CAAO;AAC5D,QAAI,CAACP,sBAAL;AACE,aAAOR,OAAQqB,CAAAA,aAAR,CAAsBtB,OAAQ0C,CAAAA,IAA9B,CAAP;AADF;AAGA,QAAID,UAAUxC,OAAQqB,CAAAA,aAAR,CAAsBtB,OAAQ0C,CAAAA,IAA9B,CAAd;AAEA,QAAKS,CAAAA,WAAL,CAAiBV,OAAjB,CAAA;AAIAzB,QAAA,GAAO,IAAKoC,CAAAA,cAAL,CAAoBpC,IAApB,CAAP;AACA,QAAIqC,qBAAqBtC,gBAAA,CAAiBC,IAAjB,CAAzB;AAIA,QAAIsC,aAAazD,cAAe0D,CAAAA,UAAf,EAAjB;AAEA,QAAIC,YAAJ;AACA,WAAOA,YAAP,GAAsBH,kBAAmBI,CAAAA,QAAnB,EAAtB,CAAqD;AAGnD,UAAIC,UAAU,IAAKC,CAAAA,WAAL,CAAiBH,YAAjB,CAAd;AACA,UAAI,CAACE,OAAL,CAAc;AAIZzD,eAAQ2D,CAAAA,cAAR,CAAuBJ,YAAvB,CAAA;AACA;AALY;AAOd,UAAIrD,SAAU0D,CAAAA,aAAV,CAAwBH,OAAxB,CAAJ;AACEJ,kBAAWQ,CAAAA,GAAX,CAAeN,YAAf,EAA6BE,OAA7B,CAAA;AADF;AAQA,UAAIK,iBAAiB5D,SAAU6D,CAAAA,aAAV,CAAwBR,YAAxB,CAArB;AACA,UAAIS,eAAe,KAAnB;AACA,UAAIF,cAAJ,CAAoB;AAClB,YAAIG,yBAAyB/D,SAAUgE,CAAAA,WAAV,CAAsBJ,cAAtB,CAA7B;AACA,YAAIK,yBACAjE,SAAUkE,CAAAA,WAAV,CAAsBN,cAAtB,CAAsCO,CAAAA,WAAtC,EADJ;AAEA,YAAIC,sBAAsBpE,SAAU6D,CAAAA,aAAV,CAAwBD,cAAxB,CAA1B;AAGA,YAAIG,sBAAJ,IAA8BnE,QAASyE,CAAAA,iBAAvC,IACI,CAACD,mBADL;AAEEN,sBAAA,GAAe,IAAf;AAFF,cAGO,KAAIG,sBAAJ,IAA8B,MAA9B,IAAwCG,mBAAxC,CAA6D;AAGlE,cAAIE,wBACAtE,SAAU6D,CAAAA,aAAV,CAAwBO,mBAAxB,CADJ;AAEA,cAAIE,qBAAJ,IACI,CAACtE,SAAU6D,CAAAA,aAAV,CAAwBS,qBAAxB,CADL;AAEER,wBAAA,GAAe,IAAf;AAFF;AALkE;AAUpE,YAAIS,YAAY,IAAhB;AACA,YAAIT,YAAJ,IAAoB,CAACF,cAArB;AACEW,mBAAA,GAAYjC,OAAZ;AADF,cAEO,KAAItC,SAAU0D,CAAAA,aAAV,CAAwBE,cAAxB,CAAJ;AACLW,mBAAA,GAAYpB,UAAWqB,CAAAA,GAAX,CAAeZ,cAAf,CAAZ;AADK;AAGP,YAAIW,SAAUlD,CAAAA,OAAd;AACEkD,mBAAA,GAAYA,SAAUlD,CAAAA,OAAtB;AADF;AAGAkD,iBAAU/B,CAAAA,WAAV,CAAsBe,OAAtB,CAAA;AA7BkB;AArB+B;AAqDrD,QAAIJ,UAAWsB,CAAAA,KAAf;AAGEtB,gBAAWsB,CAAAA,KAAX,EAAA;AAHF;AAKA,WAAOnC,OAAP;AA5E4D,GAA9D;AAuFAR,sBAAqBC,CAAAA,SAAUiB,CAAAA,WAA/B,GAA6C0B,QAAQ,CAACpC,OAAD,CAAU;GAA/D;AAQAR,sBAAqBC,CAAAA,SAAUkB,CAAAA,cAA/B,GAAgD0B,QAAQ,CAAC9D,IAAD,CAAO;GAA/D;AASAiB,sBAAqBC,CAAAA,SAAUyB,CAAAA,WAA/B,GAA6CoB,QAAQ,CAACvB,YAAD,CAAe;AAClE,QAAIwB,WAAW7E,SAAUgE,CAAAA,WAAV,CAAsBX,YAAtB,CAAf;AACA,WAAQwB,QAAR;AACE,WAAKjF,QAASkF,CAAAA,IAAd;AACE,eAAO,IAAKC,CAAAA,cAAL,CAA0C1B,YAA1C,CAAP;AACF,WAAKzD,QAASoF,CAAAA,OAAd;AACE,eAAO,IAAKC,CAAAA,cAAL,CAAoBjF,SAAUkF,CAAAA,mBAAV,CAA8B7B,YAA9B,CAApB,CAAP;AACF;AACEtD,eAAQoF,CAAAA,OAAR,CAAgB/E,MAAhB,EAAwB,8BAAxB,GAAyDyE,QAAzD,CAAA;AACA,eAAO,IAAP;AAPJ;AAFkE,GAApE;AAoBA/C,sBAAqBC,CAAAA,SAAUgD,CAAAA,cAA/B,GAAgDK,QAAQ,CAAC/B,YAAD,CAAe;GAAvE;AASAvB,sBAAqBC,CAAAA,SAAUkD,CAAAA,cAA/B,GAAgDI,QAAQ,CAACC,eAAD,CAAkB;AACxE,QAAItF,SAAUkE,CAAAA,WAAV,CAAsBoB,eAAtB,CAAuCC,CAAAA,WAAvC,EAAJ,IAA4D,UAA5D;AAGE,aAAO,IAAP;AAHF;AAKA,QAAIC,aAAa,IAAKC,CAAAA,8BAAL,CAAoCH,eAApC,CAAjB;AACA,QAAI,CAACE,UAAL;AACE,aAAO,IAAP;AADF;AAIA,QAAKE,CAAAA,yBAAL,CAA+BJ,eAA/B,EAAgDE,UAAhD,CAAA;AACA,WAAOA,UAAP;AAZwE,GAA1E;AA0BA1D,sBAAqBC,CAAAA,SAAU0D,CAAAA,8BAA/B,GAAgEE,QAAQ,CACpEL,eADoE,CACnD;GADrB;AAUAxD,sBAAqBC,CAAAA,SAAU2D,CAAAA,yBAA/B,GAA2DE,QAAQ,CAC/DN,eAD+D,EAC9CE,UAD8C,CAClC;AAC/B,QAAIK,aAAa7F,SAAUoC,CAAAA,oBAAV,CAA+BkD,eAA/B,CAAjB;AACA,QAAIO,UAAJ,IAAkB,IAAlB;AACE;AADF;AAGA,SAAK,IAAIC,IAAI,CAAR,EAAWC,SAAhB,EAA2BA,SAA3B,GAAuCF,UAAA,CAAWC,CAAX,CAAvC,EAAsDA,CAAA,EAAtD;AACE,UAAIC,SAAUC,CAAAA,SAAd,CAAyB;AACvB,YAAIC,WAAW,IAAKC,CAAAA,uBAAL,CAA6BZ,eAA7B,EAA8CS,SAA9C,CAAf;AACA,YAAIE,QAAJ,KAAiB,IAAjB;AACEjG,mBAAUmG,CAAAA,mBAAV,CAA8BX,UAA9B,EAA0CO,SAAUK,CAAAA,IAApD,EAA0DH,QAA1D,CAAA;AADF;AAFuB;AAD3B;AAL+B,GADjC;AAwBAnE,sBAAqBC,CAAAA,SAAUmE,CAAAA,uBAA/B,GAAyDG,QAAQ,CAC7DC,OAD6D,EACpDP,SADoD,CACzC;GADxB;AAIAjE,sBAAqBxB,CAAAA,sBAArB,GAA8CA,sBAA9C;AACAiG,SAAA,GAAUzE,oBAAV;AAxTA,SAAA,OAAA;AAAA,CAAA,CAAA;;\",\n\"sources\":[\"goog/html/sanitizer/safedomtreeprocessor.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n\\n/**\\n * @fileoverview A base class to safely parse and transform an HTML string\\n * using an inert DOM, which avoids executing scripts and loading images. Note:\\n * this class does *not* guarantee that the output does not contain scripts and\\n * images that eventually execute once the output is inserted into an active DOM\\n * document. If any subclass claims to produce SafeHtml output, it must be\\n * reviewed separately.\\n * @supported IE 10+, Chrome 26+, Firefox 22+, Safari 7.1+, Opera 15+\\n */\\n\\ngoog.module('goog.html.sanitizer.SafeDomTreeProcessor');\\ngoog.module.declareLegacyNamespace();\\n\\nvar Const = goog.require('goog.string.Const');\\nvar ElementWeakMap = goog.require('goog.html.sanitizer.ElementWeakMap');\\nvar Logger = goog.require('goog.log.Logger');\\nvar NodeType = goog.require('goog.dom.NodeType');\\nvar TagName = goog.require('goog.dom.TagName');\\nvar googDom = goog.require('goog.dom');\\nvar googLog = goog.require('goog.log');\\nvar noclobber = goog.require('goog.html.sanitizer.noclobber');\\nvar safe = goog.require('goog.dom.safe');\\nvar uncheckedconversions = goog.require('goog.html.uncheckedconversions');\\nvar userAgent = goog.require('goog.userAgent');\\n\\n/** @const {?Logger} */\\nvar logger = googLog.getLogger('goog.html.sanitizer.SafeDomTreeProcessor');\\n\\n/**\\n * Whether the HTML sanitizer is supported. For now mainly exclude\\n * IE9 or below, for which we know the sanitizer is insecure or broken.\\n * @const {boolean}\\n */\\nvar SAFE_PARSING_SUPPORTED =\\n    !userAgent.IE || userAgent.isDocumentModeOrHigher(10);\\n\\n/**\\n * Whether the template tag is supported.\\n * @const {boolean}\\n */\\nvar HTML_SANITIZER_TEMPLATE_SUPPORTED =\\n    !userAgent.IE || document.documentMode == null;\\n\\n/**\\n * Parses a string of unsanitized HTML and provides an iterator over the\\n * resulting DOM tree nodes. The parsing operation is inert (that is,\\n * it does not cause execution of any active content or cause the browser to\\n * issue any requests). The returned iterator is guaranteed to iterate over a\\n * parent element before iterating over any of its children.\\n * @param {string} html\\n * @return {!TreeWalker}\\n */\\nfunction getDomTreeWalker(html) {\\n  var iteratorParent;\\n  var safeHtml =\\n      uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(\\n          Const.from('Never attached to DOM.'), html);\\n  var templateElement = document.createElement('template');\\n  if (HTML_SANITIZER_TEMPLATE_SUPPORTED && 'content' in templateElement) {\\n    safe.unsafeSetInnerHtmlDoNotUseOrElse(templateElement, safeHtml);\\n    iteratorParent = templateElement.content;\\n  } else {\\n    // In browsers where <template> is not implemented, use an inert\\n    // HTMLDocument.\\n    var doc = document.implementation.createHTMLDocument('x');\\n    iteratorParent = doc.body;\\n    safe.unsafeSetInnerHtmlDoNotUseOrElse(doc.body, safeHtml);\\n  }\\n  return document.createTreeWalker(\\n      iteratorParent, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,\\n      null /* filter */, false /* entityReferenceExpansion */);\\n}\\n\\n/**\\n * Constructs a {@link SafeDomTreeProcessor} object that safely parses an input\\n * string into a DOM tree using an inert document, and creates a new tree based\\n * on the original tree, optionally transforming it in the process. The\\n * transformation is not specified in this abstract class; subclasses are\\n * supposed to override its protected methods to define a transformation that\\n * allows tags and attributes, drops entire subtrees, modifies tag names or\\n * attributes, etc.\\n * @constructor @struct @abstract\\n */\\nvar SafeDomTreeProcessor = function() {};\\n\\n/**\\n * Parses an HTML string and walks the resulting DOM forest to apply the\\n * transformation function and generate a new forest. Returns the string\\n * representation of the forest.\\n * @param {string} html\\n * @return {string}\\n * @protected @final\\n */\\nSafeDomTreeProcessor.prototype.processToString = function(html) {\\n  if (!SAFE_PARSING_SUPPORTED) {\\n    return '';\\n  }\\n\\n  var newTree = this.processToTree(html);\\n  if (noclobber.getElementAttributes(newTree).length > 0) {\\n    // We want to preserve the outer SPAN tag, because the processor has\\n    // attached attributes to it. To do so, we make a new SPAN tag the parent of\\n    // the existing root span tag, so that the rest of the function will remove\\n    // that one instead.\\n    var newRoot = googDom.createElement(TagName.SPAN);\\n    newRoot.appendChild(newTree);\\n    newTree = newRoot;\\n  }\\n  // The XMLSerializer will add a spurious xmlns attribute to the root node.\\n  var serializedNewTree = new XMLSerializer().serializeToString(newTree);\\n  // Remove the outer span before returning the string representation of the\\n  // processed copy.\\n  return serializedNewTree.slice(\\n      serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\\n};\\n\\n/**\\n * Parses an HTML string and walks the resulting DOM forest to apply the\\n * transformation function and generate a copy of the forest. Returns the forest\\n * wrapped in a common SPAN parent, so that the result is always a tree.\\n * @param {string} html\\n * @return {!HTMLSpanElement}\\n * @protected @final\\n */\\nSafeDomTreeProcessor.prototype.processToTree = function(html) {\\n  if (!SAFE_PARSING_SUPPORTED) {\\n    return googDom.createElement(TagName.SPAN);\\n  }\\n  var newRoot = googDom.createElement(TagName.SPAN);\\n  // Allow subclasses to attach properties to the root.\\n  this.processRoot(newRoot);\\n\\n  // Allow subclasses to pre-process the HTML string before performing the main\\n  // tree-based transformation.\\n  html = this.preProcessHtml(html);\\n  var originalTreeWalker = getDomTreeWalker(html);\\n\\n  // Mapping from original nodes to new nodes, used to find the parent to which\\n  // a newly processed node should be attached.\\n  var elementMap = ElementWeakMap.newWeakMap();\\n\\n  var originalNode;\\n  while (originalNode = originalTreeWalker.nextNode()) {\\n    // Make a copy of the node, potentially dropping it or changing its content,\\n    // tag name, etc.\\n    var newNode = this.createNode_(originalNode);\\n    if (!newNode) {\\n      // The transformation function chose not to copy over the node. We delete\\n      // the children so that the current treeWalker will stop iterating on\\n      // them.\\n      googDom.removeChildren(originalNode);\\n      continue;\\n    }\\n    if (noclobber.isNodeElement(newNode)) {\\n      elementMap.set(originalNode, newNode);\\n    }\\n\\n    // Finds the new parent to which newNode should be appended. The tree is\\n    // copied top-down, so the parent of the current node has already been\\n    // copied and placed into the new tree. The new parent is either the root\\n    // of the new tree or a node found using originalToNewElementMap.\\n    var originalParent = noclobber.getParentNode(originalNode);\\n    var isParentRoot = false;\\n    if (originalParent) {\\n      var originalParentNodeType = noclobber.getNodeType(originalParent);\\n      var originalParentNodeName =\\n          noclobber.getNodeName(originalParent).toLowerCase();\\n      var originalGrandParent = noclobber.getParentNode(originalParent);\\n      // The following checks if newParent is an immediate child of the inert\\n      // parent template element.\\n      if (originalParentNodeType == NodeType.DOCUMENT_FRAGMENT &&\\n          !originalGrandParent) {\\n        isParentRoot = true;\\n      } else if (originalParentNodeName == 'body' && originalGrandParent) {\\n        // The following checks if newParent is an immediate child of the\\n        // inert parent HtmlDocument.\\n        var dirtyGreatGrandParent =\\n            noclobber.getParentNode(originalGrandParent);\\n        if (dirtyGreatGrandParent &&\\n            !noclobber.getParentNode(dirtyGreatGrandParent)) {\\n          isParentRoot = true;\\n        }\\n      }\\n      var newParent = null;\\n      if (isParentRoot || !originalParent) {\\n        newParent = newRoot;\\n      } else if (noclobber.isNodeElement(originalParent)) {\\n        newParent = elementMap.get(originalParent);\\n      }\\n      if (newParent.content) {\\n        newParent = newParent.content;\\n      }\\n      newParent.appendChild(newNode);\\n    }\\n  }\\n  if (elementMap.clear) {\\n    // Clear the map. On browsers that don't support WeakMap, entries are not\\n    // automatically cleaned up.\\n    elementMap.clear();\\n  }\\n  return newRoot;\\n};\\n\\n/**\\n * Creates the root SPAN element for the new tree. This function can be\\n * overridden to add attributes to the tag. Note that if any attributes are\\n * added to the element, then {@link processToString} will not strip it from the\\n * generated string to preserve the attributes.\\n * @param {!HTMLSpanElement} newRoot\\n * @protected @abstract\\n */\\nSafeDomTreeProcessor.prototype.processRoot = function(newRoot) {};\\n\\n/**\\n * Pre-processes the input html before the main tree-based transformation.\\n * @param {string} html\\n * @return {string}\\n * @protected @abstract\\n */\\nSafeDomTreeProcessor.prototype.preProcessHtml = function(html) {};\\n\\n/**\\n * Returns a new node based on the transformation of an original node, or null\\n * if the node and all its children should not be copied over to the new tree.\\n * @param {!Node} originalNode\\n * @return {?Node}\\n * @private\\n */\\nSafeDomTreeProcessor.prototype.createNode_ = function(originalNode) {\\n  var nodeType = noclobber.getNodeType(originalNode);\\n  switch (nodeType) {\\n    case NodeType.TEXT:\\n      return this.createTextNode(/** @type {!Text} */ (originalNode));\\n    case NodeType.ELEMENT:\\n      return this.createElement_(noclobber.assertNodeIsElement(originalNode));\\n    default:\\n      googLog.warning(logger, 'Dropping unknown node type: ' + nodeType);\\n      return null;\\n  }\\n};\\n\\n/**\\n * Creates a new text node from the original text node, or null if the node\\n * should not be copied over to the new tree.\\n * @param {!Text} originalNode\\n * @return {?Text}\\n * @protected @abstract\\n */\\nSafeDomTreeProcessor.prototype.createTextNode = function(originalNode) {};\\n\\n/**\\n * Creates a new element from the original element, potentially applying\\n * transformations to the element's tagname and attributes.\\n * @param {!Element} originalElement\\n * @return {?Element}\\n * @private\\n */\\nSafeDomTreeProcessor.prototype.createElement_ = function(originalElement) {\\n  if (noclobber.getNodeName(originalElement).toUpperCase() == 'TEMPLATE') {\\n    // Processing TEMPLATE tags is not supported, they are automatically\\n    // dropped.\\n    return null;\\n  }\\n  var newElement = this.createElementWithoutAttributes(originalElement);\\n  if (!newElement) {\\n    return null;\\n  }\\n  // Copy over element attributes, applying a transformation on each attribute.\\n  this.processElementAttributes_(originalElement, newElement);\\n  return newElement;\\n};\\n\\n/**\\n * Creates a new element from the original element. This function should only\\n * either create a new element (optionally changing the tag name from the\\n * original element) or return null to prevent the entire subtree from appearing\\n * in the output. Note that TEMPLATE tags and their contents are automatically\\n * dropped, and this function is not called to decide whether to keep them or\\n * not.\\n * @param {!Element} originalElement\\n * @return {?Element}\\n * @protected @abstract\\n */\\nSafeDomTreeProcessor.prototype.createElementWithoutAttributes = function(\\n    originalElement) {};\\n\\n/**\\n * Copies over the attributes of an original node to its corresponding new node\\n * generated with {@link processNode}.\\n * @param {!Element} originalElement\\n * @param {!Element} newElement\\n * @private\\n */\\nSafeDomTreeProcessor.prototype.processElementAttributes_ = function(\\n    originalElement, newElement) {\\n  var attributes = noclobber.getElementAttributes(originalElement);\\n  if (attributes == null) {\\n    return;\\n  }\\n  for (var i = 0, attribute; attribute = attributes[i]; i++) {\\n    if (attribute.specified) {\\n      var newValue = this.processElementAttribute(originalElement, attribute);\\n      if (newValue !== null) {\\n        noclobber.setElementAttribute(newElement, attribute.name, newValue);\\n      }\\n    }\\n  }\\n};\\n\\n/**\\n * Returns the new value for an attribute, or null if the attribute should be\\n * dropped.\\n * @param {!Element} element\\n * @param {!Attr} attribute\\n * @return {?string}\\n * @protected @abstract\\n */\\nSafeDomTreeProcessor.prototype.processElementAttribute = function(\\n    element, attribute) {};\\n\\n/** @const {boolean} */\\nSafeDomTreeProcessor.SAFE_PARSING_SUPPORTED = SAFE_PARSING_SUPPORTED;\\nexports = SafeDomTreeProcessor;\\n\"],\n\"names\":[\"goog\",\"module\",\"declareLegacyNamespace\",\"Const\",\"require\",\"ElementWeakMap\",\"Logger\",\"NodeType\",\"TagName\",\"googDom\",\"googLog\",\"noclobber\",\"safe\",\"uncheckedconversions\",\"userAgent\",\"logger\",\"getLogger\",\"SAFE_PARSING_SUPPORTED\",\"IE\",\"isDocumentModeOrHigher\",\"HTML_SANITIZER_TEMPLATE_SUPPORTED\",\"document\",\"documentMode\",\"getDomTreeWalker\",\"html\",\"iteratorParent\",\"safeHtml\",\"safeHtmlFromStringKnownToSatisfyTypeContract\",\"from\",\"templateElement\",\"createElement\",\"unsafeSetInnerHtmlDoNotUseOrElse\",\"content\",\"doc\",\"implementation\",\"createHTMLDocument\",\"body\",\"createTreeWalker\",\"NodeFilter\",\"SHOW_ELEMENT\",\"SHOW_TEXT\",\"SafeDomTreeProcessor\",\"prototype\",\"processToString\",\"SafeDomTreeProcessor.prototype.processToString\",\"newTree\",\"processToTree\",\"getElementAttributes\",\"length\",\"newRoot\",\"SPAN\",\"appendChild\",\"serializedNewTree\",\"serializeToString\",\"XMLSerializer\",\"slice\",\"indexOf\",\"lastIndexOf\",\"SafeDomTreeProcessor.prototype.processToTree\",\"processRoot\",\"preProcessHtml\",\"originalTreeWalker\",\"elementMap\",\"newWeakMap\",\"originalNode\",\"nextNode\",\"newNode\",\"createNode_\",\"removeChildren\",\"isNodeElement\",\"set\",\"originalParent\",\"getParentNode\",\"isParentRoot\",\"originalParentNodeType\",\"getNodeType\",\"originalParentNodeName\",\"getNodeName\",\"toLowerCase\",\"originalGrandParent\",\"DOCUMENT_FRAGMENT\",\"dirtyGreatGrandParent\",\"newParent\",\"get\",\"clear\",\"SafeDomTreeProcessor.prototype.processRoot\",\"SafeDomTreeProcessor.prototype.preProcessHtml\",\"SafeDomTreeProcessor.prototype.createNode_\",\"nodeType\",\"TEXT\",\"createTextNode\",\"ELEMENT\",\"createElement_\",\"assertNodeIsElement\",\"warning\",\"SafeDomTreeProcessor.prototype.createTextNode\",\"SafeDomTreeProcessor.prototype.createElement_\",\"originalElement\",\"toUpperCase\",\"newElement\",\"createElementWithoutAttributes\",\"processElementAttributes_\",\"SafeDomTreeProcessor.prototype.createElementWithoutAttributes\",\"SafeDomTreeProcessor.prototype.processElementAttributes_\",\"attributes\",\"i\",\"attribute\",\"specified\",\"newValue\",\"processElementAttribute\",\"setElementAttribute\",\"name\",\"SafeDomTreeProcessor.prototype.processElementAttribute\",\"element\",\"exports\"]\n}\n"]