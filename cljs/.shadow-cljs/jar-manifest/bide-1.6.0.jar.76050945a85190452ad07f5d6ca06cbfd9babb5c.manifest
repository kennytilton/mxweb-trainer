["^ ","~:foreign-libs",[],"~:externs",[],"~:resources",[["^ ","~:cache-key",["76050945a85190452ad07f5d6ca06cbfd9babb5c"],"~:output-name","bide.impl.router.js","~:resource-id",["~:shadow.build.classpath/resource","bide/impl/router.js"],"~:resource-name","bide/impl/router.js","~:type","~:goog","~:source","/**\n * router\n *\n * @author Andrey Antukh <niwi@niwi.nz>, 2016\n * @license BSD License <https://opensource.org/licenses/BSD-2-Clause>\n */\n\ngoog.provide(\"bide.impl.router\");\n\ngoog.require(\"bide.impl.path\");\ngoog.require(\"bide.impl.helpers\");\n\ngoog.require(\"goog.object\");\n\ngoog.scope(function() {\n  var _path = bide.impl.path;\n  var isArray = bide.impl.helpers.isArray;\n\n  /**\n   * Main router class.\n   *\n   * @constructor\n   * @struct\n   */\n  function Router() {\n    this.items = [];\n    this.map = {};\n  }\n\n  /**\n   * Routing Item class\n   *\n   * @constructor\n   * @struct\n   */\n  function Route() {\n    this.re = null;\n    this.name = null;\n    this.keys = null;\n    this.format = null;\n  }\n\n  /**\n   * Insert a new route entry to the router.\n   * If router is `null` a new router is created.\n   *\n   * @param {?Router} router\n   * @param {string} path\n   * @param {!Object} name\n   * @param {*} options\n   * @return {Router}\n   */\n  function insert(router, path, name, options) {\n    var route = new Route();\n\n    route.re = _path.parse(path, options);\n    route.keys = route.re._keys;\n    route.format = _path.compileTokens(route.re._tokens);\n    route.name = name;\n\n    if (!goog.isDefAndNotNull(router)) {\n      router = new Router();\n    }\n\n    router.items.push(route);\n    name = name.toString();\n\n    if (router.map[name] === undefined) {\n      router.map[name] = [route];\n    } else {\n      router.map[name].push(route);\n    }\n\n    return router;\n  }\n\n  /**\n   * Encode query params.\n   *\n   * @param {!Object<string,*} query\n   * @return {string}\n   */\n  function encodeQueryParams(params) {\n    var encode = encodeURIComponent;\n    var keys = goog.object.getKeys(params);\n\n    var result = [];\n\n    for (var i=0; i<keys.length; i++) {\n      var key = keys[i];\n      var val = params[key];\n\n      if (val === undefined) {\n        // Do nothing\n      } else if (val === null) {\n        result.push(encode(key));\n      } else if (isArray(val)) {\n        var _result = [];\n\n        for (var y=0; y<val.length; y++) {\n          var _val = val[y];\n\n          if (_val === undefined) {\n            // do nothing\n          } else if (_val === null) {\n            _result.push(encode(key));\n          } else {\n            _result.push(encode(key) + \"=\" + encode(_val));\n          }\n        }\n\n        result.push(_result.join(\"&\"));\n      } else {\n        result.push(encode(key) + \"=\" + encode(val));\n      }\n    }\n\n    return result.join(\"&\");\n  }\n\n  /**\n   * Parses the query string to javascript object.\n   *\n   * @param {!string} query\n   * @return {Object<string,*>}\n   */\n  function parseQuery(query) {\n    var result = {};\n\n    if (! goog.isString(query)) {\n      return result;\n    }\n\n    query = query.trim().replace(/^(\\?|#|&)/, '');\n\n    if (!query) {\n      return result;\n    }\n\n    var params = query.split(\"&\");\n\n    for (var i=0; i<params.length; i++) {\n      var parts = params[i].replace(/\\+/g, ' ').split('=');\n\n      var key = parts.shift();\n      var val = parts.length > 0 ? parts.join('=') : undefined;\n      key = decodeURIComponent(key);\n\n      if (val === undefined) {\n        val = null;\n      } else {\n        val = decodeURIComponent(val);\n      }\n\n      if (result[key] === undefined) {\n        result[key] = val;\n      } else if (isArray(result[key])) {\n        result[key].push(val);\n      } else {\n        result[key] = [result[key], val];\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Match a path in the router.\n   *\n   * @param {!Router} router\n   * @param {!string} path\n   * @return {Array<*>}\n   */\n  function match(router, path) {\n    var path, query;\n\n    if (path.indexOf(\"?\") !== -1) {\n      var parts = path.split(\"?\");\n      path = parts[0];\n      query = parseQuery(parts[1]);\n    } else {\n      path = path;\n      query = null;\n    }\n\n    var items = router.items;\n    var result = null;\n    var item = null;\n\n\n    for (var i=0; i<items.length; i++) {\n      item = items[i];\n      result = item.re.exec(path);\n\n      if (!goog.isNull(result)) {\n        break;\n      }\n    }\n\n    if (goog.isNull(result)) {\n      return null;\n    }\n\n    var params = {};\n    for (var i=0; i<item.keys.length; i++) {\n      var key = item.keys[i];\n      var res = result[(i + 1)];\n      if (goog.isDefAndNotNull(res)) {\n        params[key.name] = res;\n      }\n    }\n\n    if (isEmpty(params)) {\n      params = null;\n    }\n\n    return [item.name, params, query];\n  }\n\n  /**\n   * Perform a resolve operation on router.\n   *\n   * @param {!Router} router\n   * @param {*} name\n   * @param {Object<string,*>} params\n   * @param {Object<string,*>} query\n   * @return {Array<?>}\n   */\n  function resolve(router, name, params, query) {\n    var routes = router.map[name.toString()] || null;\n\n    if (!goog.isDefAndNotNull(routes)) {\n      return null;\n    }\n\n    var result = null;\n\n    // If params is empty just check all possible\n    // options and return the first one that matches\n    // in case contrary check only routes with params\n    // because route without params does not raise\n    // exceptions causing that they are always elected\n    // independently if params are passed or not.\n    if (isEmpty(params)) {\n      for (var i=0; i<routes.length; i++) {\n        try {\n          result = routes[i].format(params);\n          break;\n        } catch (e) {}\n      }\n    } else {\n      for (var i=0; i<routes.length; i++) {\n        if (routes[i].keys.length === 0) {\n          continue;\n        }\n\n        try {\n          result = routes[i].format(params);\n          break;\n        } catch (e) {}\n      }\n    }\n\n    if (goog.isDefAndNotNull(query) && goog.isDefAndNotNull(result)) {\n      result = result + \"?\" + encodeQueryParams(query);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if provided value is an instance of Router\n   *\n   * @param {*} v\n   * @return {boolean}\n   */\n  function isRouter(v) {\n    return v instanceof Router;\n  }\n\n  /**\n   * Create an empty Router instance.\n   *\n   * @return {Router}\n   */\n  function empty() {\n    return new Router();\n  }\n\n  /**\n   * Check if provided obj is empty.\n   *\n   * @param {Object} obj\n   * @return {boolean}\n   */\n  function isEmpty(obj) {\n    for (var x in obj) { return false; }\n    return true;\n  }\n\n  var module = bide.impl.router;\n  module.insert = insert;\n  module.match = match;\n  module.resolve = resolve;\n  module.isRouter = isRouter;\n  module.empty = empty;\n  module.parseQuery = parseQuery;\n  module.encodeQueryParams = encodeQueryParams;\n});\n","~:last-modified",1619058311845,"~:requires",["~#set",["~$bide.impl.helpers","~$goog","~$goog.object","~$bide.impl.path"]],"~:pom-info",["^ ","~:group-id","~$funcool","~:artifact-id","~$bide","~:version","1.6.0","~:name","bide","~:description","Simple routing for ClojureScript","~:url","https://github.com/funcool/bide","~:id","~$funcool/bide","~:coordinate",["^L","1.6.0"]],"~:inspect-info",["^ ","~:js-str-offsets",[],"~:js-esm",false,"~:js-imports",[],"~:js-invalid-requires",[],"~:goog-provides",["bide.impl.router"],"~:js-language","es3","~:goog-module",null,"~:goog-module-legacy-namespace",false,"~:js-warnings",[["^ ","~:line",80,"~:column",29,"~:message","Bad type annotation. missing closing > See https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler for more information."]],"~:js-requires",[],"~:js-errors",[],"~:goog-requires",["bide.impl.path","bide.impl.helpers","goog.object"],"~:uses-global-buffer",false,"~:uses-global-process",false],"^J",["~#url","jar:file:/Users/kennethtilton/.m2/repository/funcool/bide/1.6.0/bide-1.6.0.jar!/bide/impl/router.js"],"~:provides",["^=",["~$bide.impl.router"]],"~:from-jar",true,"~:goog-src",false,"~:deps",["^?","^A","^>","^@"]],["^ ","^3",["76050945a85190452ad07f5d6ca06cbfd9babb5c"],"^4","bide.impl.path.js","^5",["^6","bide/impl/path.js"],"^7","bide/impl/path.js","^8","^9","^:","/**\n * Path-to-Regex - Express-style path to regexp\n *\n * Is a modified and google closure adapted implementation of\n * https://github.com/pillarjs/path-to-regexp\n * @author Andrey Antukh <niwi@niwi.nz>, 2016-2017\n * @author Blake Embrey <hello@blakeembrey.com>, 2014\n * @license MIT License <https://opensource.org/licenses/MIT>\n */\n\n\"use strict\";\n\ngoog.provide(\"bide.impl.path\");\ngoog.require(\"bide.impl.helpers\");\n\ngoog.scope(function() {\n  var isArray = bide.impl.helpers.isArray;\n\n  /**\n   * The main path matching regexp utility.\n   *\n   * @type {RegExp}\n   */\n  var PATH_REGEXP = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n    '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n    // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n    '([\\\\/.])?(?:(?:\\\\:([\\\\w\\\\-]+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n  ].join('|'), 'g');\n\n  /**\n   * Parse a string to the raw tokens.\n   *\n   * @param  {string} str\n   * @return {!Array}\n   */\n  function parseTokens (str) {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var res;\n\n    while ((res = PATH_REGEXP.exec(str)) != null) {\n      var m = res[0];\n      var escaped = res[1];\n      var offset = res.index;\n      path += str.slice(index, offset);\n      index = offset + m.length;\n\n      // Ignore already escaped sequences.\n      if (escaped) {\n        path += escaped[1];\n        continue;\n      }\n\n      var next = str[index];\n      var prefix = res[2];\n      var name = res[3];\n      var capture = res[4];\n      var group = res[5];\n      var modifier = res[6];\n      var asterisk = res[7];\n\n      // Push the current path onto the tokens.\n      if (path) {\n        tokens.push(path);\n        path = '';\n      }\n\n      var partial = prefix != null && next != null && next !== prefix;\n      var repeat = modifier === '+' || modifier === '*';\n      var optional = modifier === '?' || modifier === '*';\n      var delimiter = res[2] || '/';\n      var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\n\n      tokens.push({\n        name: name || key++,\n        prefix: prefix || '',\n        delimiter: delimiter,\n        optional: optional,\n        repeat: repeat,\n        partial: partial,\n        asterisk: !!asterisk,\n        pattern: escapeGroup(pattern)\n      });\n    }\n\n    // Match any characters still remaining.\n    if (index < str.length) {\n      path += str.substr(index);\n    }\n\n    // If the path exists, push it onto the end.\n    if (path) {\n      tokens.push(path);\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Prettier encoding of URI path segments.\n   *\n   * @param  {string}\n   * @return {string}\n   */\n  function encodeURIComponentPretty (str) {\n    return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n   *\n   * @param  {string}\n   * @return {string}\n   */\n  function encodeAsterisk (str) {\n    return encodeURI(str).replace(/[?#]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n\n  /**\n   * Escape a regular expression string.\n   *\n   * @param  {string} str\n   * @return {string}\n   */\n  function escapeString (str) {\n    return str.replace(/([.+*?=^!:${}\\(\\)\\[\\]|\\/\\\\])/g, '\\\\$1');\n  }\n\n  /**\n   * Escape the capturing group by escaping special characters and meaning.\n   *\n   * @param  {string} group\n   * @return {string}\n   */\n  function escapeGroup (group) {\n    return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n  }\n\n  /**\n   * Get the flags for a regexp from the options.\n   *\n   * @param  {Object} options\n   * @return {string}\n   */\n  function flags (options) {\n    return options.sensitive ? '' : 'i';\n  }\n\n  /**\n   * Pull out keys from a regexp.\n   *\n   * @param  {!RegExp} path\n   * @param  {!Array}  keys\n   * @return {!RegExp}\n   */\n  function regexpToRegexp (path) {\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    var keys = [];\n\n    if (groups) {\n      for (var i = 0; i < groups.length; i++) {\n        keys.push({\n          name: i,\n          prefix: null,\n          delimiter: null,\n          optional: false,\n          repeat: false,\n          partial: false,\n          asterisk: false,\n          pattern: null\n        });\n      }\n    }\n\n    return [path, keys];\n  }\n\n  /**\n   * Expose a function for taking tokens and returning a RegExp.\n   *\n   * @param  {!Array}  tokens\n   * @param  {Object=} options\n   * @return {!RegExp}\n   */\n  function tokensToRegExp (tokens, options) {\n    options = options || {};\n\n    var strict = options.strict;\n    var end = options.end !== false;\n    var route = '';\n    var lastToken = tokens[tokens.length - 1];\n    var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken);\n\n    // Iterate over the tokens and create our regexp string.\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        route += escapeString(token);\n      } else {\n        var prefix = escapeString(token.prefix);\n        var capture = '(?:' + token.pattern + ')';\n\n        if (token.repeat) {\n          capture += '(?:' + prefix + capture + ')*';\n        }\n\n        if (token.optional) {\n          if (!token.partial) {\n            capture = '(?:' + prefix + '(' + capture + '))?';\n          } else {\n            capture = prefix + '(' + capture + ')?';\n          }\n        } else {\n          capture = prefix + '(' + capture + ')';\n        }\n\n        route += capture;\n      }\n    }\n\n    // In non-strict mode we allow a slash at the end of match. If the path to\n    // match already ends with a slash, we remove it for consistency. The slash\n    // is valid at the end of a path match, not in the middle. This is important\n    // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n    if (!strict) {\n      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n    }\n\n    if (end) {\n      route += '$';\n    } else {\n      // In non-ending mode, we need the capturing groups to match as much as\n      // possible by using a positive lookahead to the end or next path segment.\n      route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n    }\n\n    return new RegExp('^' + route, flags(options));\n  }\n\n  /**\n   * Compile a string to a template function for the path tokens.\n   *\n   * @param  {!Array}             tokens\n   * @return {!function(Object=, Object=)}\n   */\n  function compileTokens (tokens) {\n    // Compile all the tokens into regexps.\n    var matches = new Array(tokens.length);\n\n    // Compile all the patterns before compilation.\n    for (var i = 0; i < tokens.length; i++) {\n      if (typeof tokens[i] === 'object') {\n        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n      }\n    }\n\n    return function (obj, opts) {\n      var path = '';\n      var data = obj || {};\n      var options = opts || {};\n      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          path += token;\n\n          continue;\n        }\n\n        var value = data[token.name];\n        var segment;\n\n        if (value == null) {\n          if (token.optional) {\n            // Prepend partial segment prefixes.\n            if (token.partial) {\n              path += token.prefix;\n            }\n\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to be defined');\n          }\n        }\n\n        if (isArray(value)) {\n          if (!token.repeat) {\n            throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n          }\n\n          if (value.length === 0) {\n            if (token.optional) {\n              continue;\n            } else {\n              throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n            }\n          }\n\n          for (var j = 0; j < value.length; j++) {\n            segment = encode(value[j]);\n\n            if (!matches[i].test(segment)) {\n              throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n            }\n\n            path += (j === 0 ? token.prefix : token.delimiter) + segment;\n          }\n\n          continue;\n        }\n\n        segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n        }\n\n        path += token.prefix + segment;\n      }\n\n      return path;\n    };\n  }\n\n  /**\n   * Create a path regexp from string input.\n   *\n   * @param  {string}  path\n   * @param  {!Array}  keys\n   * @param  {!Object} options\n   * @return {!RegExp}\n   */\n  function parse(path, options) {\n    if (options===undefined) options = {};\n\n    var tokens = parseTokens(path);\n    var re = tokensToRegExp(tokens, options);\n\n    // Attach keys back to the regexp.\n    var keys = [];\n    for (var i=0; i < tokens.length; i++) {\n      if (typeof tokens[i] !== 'string') {\n        keys.push(tokens[i]);\n      }\n    }\n\n    re._tokens = tokens;\n    re._keys = keys;\n    return re;\n  }\n\n  var self = bide.impl.path;\n  self.parse = parse;\n  self.compileTokens = compileTokens;\n});\n","^;",1619058311845,"^<",["^=",["^>","^?"]],"^B",["^ ","^C","^D","^E","^F","^G","1.6.0","^H","bide","^I","Simple routing for ClojureScript","^J","https://github.com/funcool/bide","^K","^L","^M",["^L","1.6.0"]],"^N",["^ ","^O",[],"^P",false,"^Q",[],"^R",[],"^S",["bide.impl.path"],"^T","es3","^U",null,"^V",false,"^W",[["^ ","^X",112,"^Y",5,"^Z","Bad type annotation. expecting a variable name in a @param tag. See https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler for more information."],["^ ","^X",124,"^Y",5,"^Z","Bad type annotation. expecting a variable name in a @param tag. See https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler for more information."]],"^[",[],"^10",[],"^11",["bide.impl.helpers"],"^12",false,"^13",false],"^J",["^14","jar:file:/Users/kennethtilton/.m2/repository/funcool/bide/1.6.0/bide-1.6.0.jar!/bide/impl/path.js"],"^15",["^=",["^A"]],"^17",true,"^18",false,"^19",["^?","^>"]],["^ ","^3",["76050945a85190452ad07f5d6ca06cbfd9babb5c"],"^4","bide.impl.helpers.js","^5",["^6","bide/impl/helpers.js"],"^7","bide/impl/helpers.js","^8","^9","^:","/**\n * Helpers\n *\n * @author Andrey Antukh <niwi@niwi.nz>, 2016-2017\n * @license MIT License <https://opensource.org/licenses/MIT>\n */\n\ngoog.provide(\"bide.impl.helpers\");\n\ngoog.scope(function() {\n  var self = bide.impl.helpers;\n\n  if (!Object.keys) Object.keys = function(o) {\n    if (o !== Object(o))\n      throw new TypeError('Object.keys called on a non-object');\n    var k=[],p;\n    for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p);\n    return k;\n  };\n\n  self.keys = function(o) {\n    if (!goog.isDefAndNotNull(o)) {\n      return [];\n    }\n    return Object.keys(o);\n  };\n\n  self.isArray = Array.isArray || function (val) {\n    return !! val && '[object Array]' == toString.call(val);\n  };\n});\n\n\n","^;",1619058311845,"^<",["^=",["^?"]],"^B",["^ ","^C","^D","^E","^F","^G","1.6.0","^H","bide","^I","Simple routing for ClojureScript","^J","https://github.com/funcool/bide","^K","^L","^M",["^L","1.6.0"]],"^N",["^ ","^O",[],"^P",false,"^Q",[],"^R",[],"^S",["bide.impl.helpers"],"^T","es3","^U",null,"^V",false,"^[",[],"^11",[],"^12",false,"^13",false],"^J",["^14","jar:file:/Users/kennethtilton/.m2/repository/funcool/bide/1.6.0/bide-1.6.0.jar!/bide/impl/helpers.js"],"^15",["^=",["^>"]],"^17",true,"^18",false,"^19",["^?"]]],"~:data-readers",null,"~:shadow.build.classpath/CACHE-TIMESTAMP",1645584859000]