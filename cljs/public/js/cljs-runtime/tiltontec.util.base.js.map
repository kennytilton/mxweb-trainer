{"version":3,"sources":["tiltontec/util/base.cljc"],"mappings":";AAGS,AAACA;AAIV,6CAAA,7CAAeC;AAKf,6CAAA,7CAAeC;AACf,8CAAA,9CAAeC;AACf,2CAAA,3CAAeC;AACf,AAAKC,+BAAS,6CAAA,7CAACC;AAEf,gCAAA,hCAAMC,wEAAWC,EAAEC;AAAnB,AACE,uDAAA,HAAKD,QAAgB,4CAAKC;;AAI5B,AAAA,+BAAA,uCAAAC,tEAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,kEAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,oEAAA,pEAAME,+EAAUR,EAAIc;AAApB,AAEE,oBAAMrB;AAAN,AACE,oBAAMO;AAAN,AACE,IAAMe,OAAK,AAACC,8CAAMC,cAAI,wFAAA,xFAACC,+CAAOtB;AAA9B,AACE,OAACuB,yGAAQJ,KAAK,AAAChB,8BAAUC,EAAEc;;AAF/B;;;AADF;;;;AAFF,CAAA,uDAAA,vDAAMN;;AAAN;AAAA,CAAA,iDAAA,WAAAC,5DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,SAAAD;;;AAAA,AAYA,gCAAA,hCAAMW,wEAAWC,GAAGC,GAAGC,GAAGC;AAA1B,AACE,IAAAC,uCAAU7B;IAAV8B,uCAAqB,4CAAA,3CAAK9B;AAA1B,AAAA,4CAAA8B,3CAAU9B;;AAAV,IAAA,AACE,GACE,EAAA,sDAAA,rDAAI0B,MAAG1B,gDAAAA,4CAAW2B;AAClB,AAACP,8CAAMR,6BAASgB;;AAFlB,GAGE,CAAG5B,2CAAW2B;AACd,MAAO,KAAAI,MACE,CAAA,2EAAA,JAAgCJ,oDAC9B,AAACP,8CAAMjB,8BAAU,AAACY,gBAAMa,SACtB,AAACI,eAAKJ;;AAPrB;;;AAQA,QAACH,mCAAAA,qCAAAA;UATH,AAAA,4CAAAI,3CAAU7B;;AA6CZ,gCAAA,hCAAMiC,wEAAWC;AAAjB,AAEW,IAAAC,mBAAI,iBAAAC,qBAAa,AAACE,eAAKJ;AAAnB,AAAA,oBAAAE;AAAA,AAAA,QAAAA,JAAWC;AAAX,AACE,OAAA,mFAAOA;;AADT;;;AAAJ,AAAA,oBAAAF;AAAAA;;AAEE,OAACI,eAAKL","names":["cljs.core/enable-console-print!","tiltontec.util.base/*trx?*","tiltontec.util.base/*trc-ensure*","tiltontec.util.base/*trx-path-id*","tiltontec.util.base/*trxdepth*","tiltontec.util.base/last-trc","cljs.core.atom","tiltontec.util.base/call-trc$","s","bits","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","tiltontec.util.base/call-trc","seq26591","G__26592","cljs.core/first","cljs.core/next","self__4851__auto__","os","path","cljs.core.apply","cljs.core/str","cljs.core.repeat","cljs.core.println","tiltontec.util.base/call-wtrx","fn","lo","hi","trxargs","*trxdepth*-orig-val__26597","*trxdepth*-temp-val__26598","js/Error","cljs.core/rest","tiltontec.util.base/type-cljc","x","or__4253__auto__","temp__5753__auto__","m","cljs.core/meta","cljs.core/type"],"sourcesContent":["(ns tiltontec.util.base\n  (:require [clojure.string :as str]))\n\n#?(:cljs (enable-console-print!))\n\n;; ---- debug print statement hacks ---------------------\n\n(def ^:dynamic *trx?* true)\n\n#_\n(alter-var-root #'*trx?* not)\n\n(def ^:dynamic *trc-ensure* nil)\n(def ^:dynamic *trx-path-id* nil)\n(def ^:dynamic *trxdepth* 0)\n(def last-trc (atom 0)) ;; s/b universal time\n\n(defn call-trc$ [s bits]\n  (str s \": \" #?(:cljs (str bits)\n                 :clj (str/join \", \" bits))))\n\n\n(defn call-trc [s & os]\n  ;; (break) ;; uncomment to escape loop\n  (when *trx?*\n    (when s\n      (let [path (apply str (repeat *trxdepth* \".\"))]\n        (println path (call-trc$ s os))))))\n\n(defmacro trx [label & vals]\n  `(call-trc ~(when (not (nil? label))\n                (str label))\n             ~@vals))\n\n(defn call-wtrx [fn lo hi trxargs]\n  (binding [*trxdepth* (inc *trxdepth*)]\n    (cond\n      (<= lo *trxdepth* hi)\n      (apply call-trc trxargs)\n      (> *trxdepth* hi)\n      (throw (#?(:cljs js/Error. :clj Exception.)\n               (str \"wtrx exceeded max depth \" hi \":\"\n                 (apply call-trc$ (first trxargs)\n                   (rest trxargs))))))\n    (fn)))\n\n(defmacro wtrx [[lo hi & trxargs] & body]\n  `(call-wtrx (fn [] ~@body) ~lo ~hi (list ~@trxargs)))\n\n(defmacro prog1 [& body]\n  `(let [result# ~(first body)]\n     ~@(rest body)\n     result#))\n\n(defmacro b-when [var form & body]\n  `(when-let [~var ~form]\n     ~@body))\n\n(defmacro unless [form & body]\n  `(when-not ~form\n     ~@body))\n\n;; --- easy access to maps in refs ----\n\n(defmacro def-rmap-slots [reader-prefix & slots]\n  `(do\n     ~@(map (fn [slot#]\n              `(defn ~(symbol (str (or reader-prefix \"\")\n                                   slot#))\n                 [~'ref]\n                 (~(keyword slot#) @~'ref))) slots)))\n\n(defmacro def-rmap-meta-slots [reader-prefix & slots]\n  `(do\n     ~@(map (fn [slot#]\n              `(defn ~(symbol (str (or reader-prefix \"\")\n                                   slot#))\n                 [~'ref]\n                 (~(keyword slot#) (meta ~'ref)))) slots)))\n\n(defn type-cljc [x]\n  #?(:clj (type x)\n     :cljs (or (when-let [m (meta x)]\n                 (:type m))\n             (type x))))\n"]}