{"version":3,"sources":["taoensso/tufte/impl.cljc"],"mappings":"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","names":["this__4491__auto__","writer__4492__auto__","opt__4493__auto__","cljs.core/-write","taoensso.tufte.impl/Time","taoensso.tufte.impl/->Time","id","t","taoensso.tufte.impl/TimeSpan","taoensso.tufte.impl/->TimeSpan","t0","t1","cljs.core/deref","taoensso.tufte.impl/PStats","taoensso.tufte.impl/->PStats","pd","tspans","realized_","_","cljs.core/realized?","taoensso.tufte.impl/PState","taoensso.tufte.impl/->PState","acc","id-times","id-stats","taoensso.tufte.impl/PData","taoensso.tufte.impl/->PData","nmax","pstate_","this","taoensso.tufte.impl/deref-pdata","taoensso.tufte.impl/new-pdata-local","taoensso.encore/now-nano","cljs.core/volatile!","taoensso.tufte.impl/new-pdata-dynamic","cljs.core.atom","cljs.core/List","cljs.core/Delay","taoensso.tufte.impl/deref-pstats","taoensso.tufte.impl/*pdata*","stack","state_","taoensso.tufte.impl/pdata-proxy-get","taoensso.tufte.impl/pdata-proxy-pop","temp__5751__auto__","stashed","cljs.core/vreset!","taoensso.tufte.impl/pdata-proxy-push","v","to-stash","taoensso.tufte.impl/ElapsedTimeAcc","taoensso.tufte.impl/->ElapsedTimeAcc","tsum","max-t1","sort-tspans","cljs.core.sort_by","tspan","taoensso.tufte.impl/tspans->tsum","cljs.core/empty?","sorted-tspans","cljs.core.reduce","Math/max","taoensso.tufte.impl/merge-tspans","tspans0","tspans1","n0","cljs.core/count","n1","tspans2","cljs.core.into","taoensso.tufte.impl/times-into-id-times","to-id-times","from-times","cljs.core/not-empty","taoensso.encore/force-ref","cljs.core/persistent!","m","in","cljs.core.assoc_BANG_","cljs.core.conj","cljs.core.get","cljs.core/transient","or__4253__auto__","pstate","cljs.core/reduce-kv","times","stats<times","taoensso.tufte.stats/stats","merged","taoensso.tufte.stats/merge-stats","cljs.core.assoc","taoensso.tufte.impl/fast-into","c0","c1","taoensso.tufte.impl/merge-stats-when-needed","stats","var_args","G__34260","taoensso.tufte.impl/merge-pstats","js/Error","ps0","ps1","taoensso.tufte.impl.merge_pstats","vec__34269","cljs.core.nth","pd0","pd1","cljs.core/long","pd0-t0","ps0-t1","pd1-t0","ps1-t1","pd2-t0","ps2-t1","pd0-pstate","pd1-pstate","pd0-id-times","pd1-id-times","pd0-id-stats","pd1-id-stats","pd2-ids","cljs.core/keys","pd2-id-times","pd2-id-stats","p__34275","vec__34277","pd0-times","pd0-stats","pd1-times","pd1-stats","pd2-times","pd2-stats","pd2","taoensso.tufte.impl/capture-time!","ns-elapsed","cljs.core/Atom","?pulled-times","old-times","new-times","cljs.core/compare-and-set!","temp__5753__auto__","cljs.core.swap_BANG_","taoensso.tufte.impl/compact-pstate","pulled-times","dynamic?","vec__34306","vec__34312","new-acc","js/taoensso","js/taoensso.tufte","js/taoensso.tufte.impl","js/taoensso.tufte.impl.handlers_","taoensso.tufte.impl/handlers_","taoensso.tufte.impl/handle-blocking!","taoensso.encore/run-kv!","f","e34318","e","e34321","cljs.core.println","taoensso.tufte.impl/handle!"],"sourcesContent":["(ns taoensso.tufte.impl\n  \"Private implementation details.\n  `profiled` -> [<result> <derefable-and-mergeable-pstats>].\n\n  Profiling consists of:\n    1. State init   ; On  thread\n    2. Capture      ; On  thread\n    3. State deref  ; On  thread\n    4. ?Merging     ; Off thread, on demand (deferred cost)\n    5. ?Realization ; Off thread, on demand (deferred cost)\n\n  Basic implementation:\n    - Capture [<id> <elapsed>]s into single mutable acc\n      - May compact acc      to id-times, {<id> (<time>        ...)}\n      - May compact id-times to id-stats, {<id> (<stats/stats> ...)}\n    - Merge pours (read-only) acc0 + acc1 into id-times\n      - May compact id-times to id-stats, {<id> (<stats/stats> ...)}\n    - Realization:\n        - Generates {<id> <stats/stats>} from id-times.\n        - Merges with id-stats.\"\n\n  (:require [clojure.string  :as str]\n            [taoensso.encore :as enc :refer-macros []]\n            [taoensso.tufte.stats :as stats])\n  #?(:clj\n     (:import [java.util LinkedList]\n              [java.util.concurrent ArrayBlockingQueue]))\n  #?(:cljs\n     (:require-macros\n      [taoensso.tufte.impl :refer [mt-acc mt-add mt-count atom?]])))\n\n;;;; Mutable accumulators\n\n(deftype Time     [id ^long t])\n(deftype TimeSpan [^long t0 ^long t1])\n(comment (enc/qb 1e6 (Time. :foo 1000))) ; 33.59\n\n(defmacro ^:private mt-acc     [] `(enc/if-cljs (cljs.core/array) (LinkedList.)))\n(defmacro ^:private mt-add [mt x] `(enc/if-cljs (.push   ~mt ~x) (.add  ~(with-meta mt {:tag 'LinkedList}) ~x)))\n(defmacro ^:private mt-count [mt] `(enc/if-cljs (alength ~mt)    (.size ~(with-meta mt {:tag 'LinkedList}))))\n\n(comment (enc/qb 1e6 (mt-acc) (atom nil))) ; [29.14 57.76]\n\n;;;; PStats (Profiling Stats)\n;; API-level state we'll return from `profiled`: derefable, mergeable\n\n(deftype PStats [pd ^long t1 tspans realized_]\n  #?@(:clj  [clojure.lang.IDeref    (deref     [_]           @realized_)]\n      :cljs [             IDeref   (-deref     [_]           @realized_)])\n  #?@(:clj  [clojure.lang.IPending (isRealized [_] (realized? realized_))]\n      :cljs [             IPending (-realized? [_] (realized? realized_))]))\n\n;;;; PData (Profiling Data)\n;; Implementation-level state while profiling,\n;;   - id-times: ?{<id> (<time>        ...)}\n;;   - id-stats: ?{<id> (<stats/stats> ...)}\n\n(declare ^:private deref-pdata)\n(deftype PState [acc id-times id-stats])\n(deftype  PData [^long nmax ^long t0 pstate_]\n  #?@(:clj  [clojure.lang.IDeref  (deref [this] (deref-pdata this))]\n      :cljs [             IDeref (-deref [this] (deref-pdata this))]))\n\n(defn new-pdata-local   [^long nmax] (let [t0 (enc/now-nano*)] (PData. nmax t0 (volatile! (PState. (mt-acc)   nil nil)))))\n(defn new-pdata-dynamic [^long nmax] (let [t0 (enc/now-nano*)] (PData. nmax t0 (atom      (PState. (atom nil) nil nil)))))\n\n(comment (enc/qb 1e6 (new-pdata-local 10) (new-pdata-dynamic 10))) ; [98.18 138.28]\n\n(declare ^:private deref-pstats)\n(defn- deref-pdata \"PData->PStats\" [^PData pd]\n  ;; NB (.-acc pd) should never be mutated from this point!\n  (let [t1     (enc/now-nano*)\n        t0     (.-t0 pd)\n        tspans (list (TimeSpan. t0 t1))]\n\n    (PStats. pd t1 tspans (delay (deref-pstats pd t1 tspans)))))\n\n(comment (enc/qb 1e6 @(new-pdata-local 10))) ; 245.08\n\n(def ^:dynamic *pdata* \"nnil iff dynamic profiling active\" nil)\n\n#?(:clj ; get nnil iff thread-local profiling active\n   (let [stack (java.util.Stack.) ; To support nesting\n         ^ThreadLocal proxy (proxy [ThreadLocal] [])]\n\n     (defn pdata-proxy-get [] (.get proxy))\n     (defn pdata-proxy-pop []\n       (if-let [stashed (when-not (.empty stack) (.pop stack))]\n         (do (.set proxy stashed) stashed)\n         (do (.set proxy nil)     nil)))\n\n     (defn pdata-proxy-push [v]\n       (if-let [to-stash (.get proxy)]\n         (do (.push stack to-stash) (.set proxy v) v)\n         (do                        (.set proxy v) v))))\n\n   :cljs\n   (let [stack #js [] ; To support nesting\n         state_ (volatile! false)] ; Automatically thread-local in js\n\n     (defn pdata-proxy-get [] @state_)\n     (defn pdata-proxy-pop []\n       (if-let [stashed (.pop stack)]\n         (vreset! state_ stashed)\n         (vreset! state_ nil)))\n\n     (defn pdata-proxy-push [v]\n       (if-let [to-stash @state_]\n         (do (.push stack to-stash) (vreset! state_ v))\n         (do                        (vreset! state_ v))))))\n\n(comment\n  (pdata-proxy-push \"foo\")\n  (pdata-proxy-pop)\n  (enc/qb 1e6 *pdata* (pdata-proxy-get)) ; [63.7 48.77]\n  (enc/qb 1e6  ; [507.58 74.62]\n    (binding [*pdata* \"foo\"])\n    (try (pdata-proxy-push \"foo\") (finally (pdata-proxy-pop)))))\n\n;;;; TimeSpan utils\n\n(deftype ElapsedTimeAcc [^long tsum ^long max-t1])\n(let [sort-tspans (fn [tspans] (sort-by (fn [^TimeSpan tspan] (.-t0 tspan)) tspans))]\n  (defn- tspans->tsum\n    \"Returns `tsum` (elapsed time) given collection of `TimeSpan`s.\n    Based on https://codereview.stackexchange.com/a/126927.\"\n    ^long [tspans]\n    (if (empty? tspans)\n      0\n      (let [sorted-tspans (sort-tspans tspans)] ; O(n.logn)\n        (.-tsum ^ElapsedTimeAcc\n          (reduce\n            (fn [^ElapsedTimeAcc acc ^TimeSpan tspan]\n              (let [t1     (.-t1     tspan)\n                    max-t1 (.-max-t1 acc)]\n                (if (> t1 max-t1)\n                  (let [t0   (.-t0   tspan)\n                        tsum (.-tsum acc)]\n                    (ElapsedTimeAcc. (+ tsum (- t1 (Math/max t0 max-t1))) t1))\n                  acc)))\n            (ElapsedTimeAcc. 0 0)\n            sorted-tspans))))))\n\n(comment\n  (tspans->tsum nil)\n  (tspans->tsum [])\n  (tspans->tsum [(TimeSpan. 1   3) (TimeSpan. 3 6)])\n  (tspans->tsum [(TimeSpan. 3   6) (TimeSpan. 1 3)])\n  (tspans->tsum [(TimeSpan. 1  10) (TimeSpan. 3 6)])\n  (enc/qb 1e6\n    (tspans->tsum\n      [(TimeSpan. 10 14)\n       (TimeSpan.  4 18)\n       (TimeSpan. 19 20)\n       (TimeSpan. 19 20)\n       (TimeSpan. 13 20)])))\n\n(defn- merge-tspans [^long nmax ^long t1 tspans0 tspans1]\n  (let [n0      (count tspans0)\n        n1      (count tspans1)\n        tspans2 (if (> n1 n0) (into tspans1 tspans0) (into tspans0 tspans1))]\n\n    (if (> (+ n0 n1) nmax) ; Compact, may lose some accuracy\n      (let [tsum (tspans->tsum tspans2)]\n        (list (TimeSpan. (- t1 tsum) t1)))\n      tspans2)))\n\n(comment\n  (merge-tspans 2 50\n    (list (TimeSpan. 1 10) (TimeSpan. 5  20))\n    (list (TimeSpan. 1 10) (TimeSpan. 20 50))))\n\n;;;;\n\n(defn- times-into-id-times\n  \"NB treats `from-times` as read-only (may be mutable `acc`)!\"\n  [to-id-times from-times]\n  (not-empty\n    (if-let [from-times (enc/force-ref from-times)]\n      (persistent!\n        (reduce\n          (fn [m ^Time in]\n            (let [id (.-id in)\n                  t  (.-t  in)]\n              (assoc! m id (conj (get m id) t))))\n          (transient (or to-id-times {}))\n          from-times))\n      to-id-times)))\n\n(comment\n  (times-into-id-times nil nil)\n  (times-into-id-times {}  nil)\n  (let [mt (mt-acc)]\n    (mt-add mt (Time. :foo 2))\n    (times-into-id-times {:foo '(1)} mt)))\n\n(defn- deref-pstats\n  \"PStats->{:clock _ :stats {<id> <stats/stats>}} (API output)\"\n  [^PData pd ^long t1 tspans]\n  (let [t0      (.-t0      pd)\n        pstate_ (.-pstate_ pd)\n        ^PState pstate (enc/force-ref pstate_)\n        id-times (.-id-times pstate)\n        id-stats (.-id-stats pstate)\n        id-times (times-into-id-times id-times (.-acc pstate))\n        id-stats ; Final {<id> <stats/stats>}\n        (reduce-kv\n          (fn [m id times]\n            (let [stats<times (stats/stats times)\n                  merged (reduce stats/merge-stats stats<times (get id-stats id))]\n              (assoc m id merged)))\n          id-times\n          id-times)]\n\n    {:stats id-stats\n     :clock {:t0 t0 :t1 t1 :total (tspans->tsum tspans)}}))\n\n(comment @@(new-pdata-local 10))\n\n(defn- fast-into [c0 c1] (if (> (count c0) (count c1)) (into c0 c1) (into c1 c0)))\n(comment (fast-into nil nil))\n\n(defn- merge-stats-when-needed [^long nmax stats]\n  (if (<= (count stats) nmax)\n    stats\n    (list (reduce stats/merge-stats stats))))\n\n(defn merge-pstats \"Compacting merge\"\n  ([     ps0 ps1] (merge-pstats nil ps0 ps1))\n  ([nmax ps0 ps1]\n   (if ps0\n     (if ps1\n       (let [^PStats ps0       ps0\n             ^PStats ps1       ps1\n             ^PData  pd0 (.-pd ps0)\n             ^PData  pd1 (.-pd ps1)\n\n             nmax (long (or nmax (.-nmax pd0)))\n             pd0-t0 (.-t0 pd0)\n             ps0-t1 (.-t1 ps0)\n             pd1-t0 (.-t0 pd1)\n             ps1-t1 (.-t1 ps1)\n\n             pd2-t0  (if (< pd0-t0 pd1-t0) pd0-t0 pd1-t0)\n             ps2-t1  (if (> ps0-t1 ps1-t1) ps0-t1 ps1-t1)\n             tspans2 (merge-tspans nmax ps2-t1 (.-tspans ps0) (.-tspans ps1))\n\n             ^PState pd0-pstate (enc/force-ref (.-pstate_ pd0))\n             ^PState pd1-pstate (enc/force-ref (.-pstate_ pd1))\n\n             pd0-id-times (times-into-id-times (.-id-times pd0-pstate) (.-acc pd0-pstate))\n             pd1-id-times (times-into-id-times (.-id-times pd1-pstate) (.-acc pd1-pstate))\n             pd0-id-stats (.-id-stats pd0-pstate)\n             pd1-id-stats (.-id-stats pd1-pstate)\n\n             ;; All ids in pd0 or pd1\n             pd2-ids (keys (conj (or pd0-id-times {}) pd1-id-times))\n\n             ;; Merge pd1 into pd0 to get pd2\n             [pd2-id-times pd2-id-stats]\n             (reduce\n               (fn [[pd2-id-times pd2-id-stats] id]\n                 (let [pd0-times (get pd0-id-times id)\n                       pd0-stats (get pd0-id-stats id)\n                       pd1-times (get pd1-id-times id)\n                       pd1-stats (get pd1-id-stats id)\n\n                       pd2-times (fast-into pd0-times pd1-times)\n                       pd2-stats (fast-into pd0-stats pd1-stats)]\n\n                   (if (<= (count pd2-times) nmax) ; Common case\n                     [(assoc pd2-id-times id pd2-times)\n                      (assoc pd2-id-stats id pd2-stats)]\n\n                     ;; Times need compaction\n                     (let [stats<times (stats/stats pd2-times)]\n                       [(assoc pd2-id-times id nil)\n                        (assoc pd2-id-stats id\n                          (merge-stats-when-needed nmax\n                            (conj pd2-stats stats<times)))]))))\n\n               [pd0-id-times pd0-id-stats]\n               pd2-ids)\n\n             pd2 (PData. nmax pd2-t0 (PState. nil pd2-id-times pd2-id-stats))]\n         (PStats. pd2 ps2-t1 tspans2 (delay (deref-pstats pd2 ps2-t1 tspans2))))\n\n       ps0)\n     ps1)))\n\n;;;; Time capture\n\n(defmacro ^:private atom? [x]\n  `(enc/if-cljs\n     (instance?    cljs.core.Atom ~x)\n     (instance? clojure.lang.Atom ~x)))\n\n(declare ^:private compact-pstate)\n(defn capture-time! [^PData pd id ns-elapsed]\n  (let [nmax    (.-nmax    pd)\n        pstate_ (.-pstate_ pd)\n        ^PState pstate @pstate_\n        acc (.-acc pstate)]\n\n    (if (atom? acc)\n\n      ;; Dynamic profiling\n      (let [?pulled-times\n            (loop []\n              (let [old-times @acc\n                    new-times (conj old-times (Time. id ns-elapsed))]\n                (if (<= (count new-times) nmax)\n                  (if (compare-and-set! acc old-times new-times) nil (recur))\n                  (if (compare-and-set! acc old-times nil) new-times (recur)))))]\n\n        (when-let [times ?pulled-times] ; Do compaction, rare\n          (let [t0 (enc/now-nano*)]\n            ;; Contention against `pstate_` unlikely since we just drained `acc`\n            (swap! pstate_ (fn [pstate] (compact-pstate pstate times nmax true)))\n            (recur pd :tufte/compaction (- (enc/now-nano*) t0)))))\n\n      (do ; Common case: thread-local profiling\n        (mt-add acc (Time. id ns-elapsed))\n\n        (when (> (mt-count acc) nmax) ; Do compaction, rare\n          (let [t0 (enc/now-nano*)]\n            (vreset! pstate_ (compact-pstate pstate acc nmax false))\n            (recur pd :tufte/compaction (- (enc/now-nano*) t0))))))))\n\n(defn- compact-pstate [^PState pstate pulled-times ^long nmax dynamic?]\n  ;; Note that compaction expense doesn't distort p times unless there's\n  ;; p nesting (where outer p time includes inner p's capture time).\n  (let [id-times (.-id-times pstate)\n        id-stats (.-id-stats pstate)\n        id-times (times-into-id-times id-times pulled-times)\n\n        [id-times id-stats]\n        (reduce-kv\n          (fn [acc id times]\n            (if (<= (count times) nmax)\n              acc\n              (let [[id-times id-stats] acc\n                    stats<times (stats/stats times)]\n                [(assoc id-times id nil)\n                 (assoc id-stats id\n                   (merge-stats-when-needed nmax\n                     (conj (get id-stats id) stats<times)))])))\n\n          [id-times id-stats]\n          id-times)\n\n        new-acc (if dynamic? (.-acc pstate) (mt-acc))]\n\n    (PState. new-acc id-times id-stats)))\n\n(comment\n  (try\n    (pdata-proxy-push (new-pdata-local 1e7))\n    (enc/qb 1e6 (capture-time! (pdata-proxy-get) :foo 1))\n    (finally (pdata-proxy-pop)))) ; 98.35\n\n;;;; Output handlers\n\n(enc/defonce handlers_ \"{<hid> <handler-fn>}\" (atom nil))\n\n#?(:clj\n   (enc/defonce ^:private ^ArrayBlockingQueue handler-queue\n     \"While user handlers should ideally be non-blocking, we'll use a queue\n     here to be safe + make sure we never tie up the execution thread.\"\n     (ArrayBlockingQueue. 1024)))\n\n(defn- handle-blocking! [m]\n  (enc/run-kv!\n    (fn [id f]\n      (enc/catching (f m) e\n        (enc/catching ; Esp. nb for Cljs\n          (println (str \"WARNING: Uncaught Tufte `\" id \"` handler error\\n\" e)))))\n    @handlers_))\n\n#?(:clj  (declare ^:private handler-thread_))\n#?(:cljs (defn handle! [m] (handle-blocking! m) nil))\n#?(:clj  (defn handle! [m] (.offer handler-queue m) @handler-thread_ nil))\n#?(:clj\n   (defonce ^:private handler-thread_\n     (delay\n       (let [f (fn []\n                 (loop []\n                   (let [m (.take handler-queue)]\n                     ;; Note: just drop if no registered handlers\n                     (handle-blocking! m)\n                     (recur))))]\n         (doto (Thread. f)\n           (.setDaemon true)\n           (.start))))))\n"]}