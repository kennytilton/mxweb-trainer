{"version":3,"sources":["tiltontec/cell/core.cljc"],"mappings":"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","names":["var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","tiltontec.cell.core/make-cell","seq29366","self__4852__auto__","cljs.core/seq","kvs","options","cljs.core.apply","cljs.core/hash-map","cljs.core.atom","cljs.core.merge","tiltontec.cell.base/unbound","tiltontec.cell.core/make-c-formula","seq29369","rule","js/Error","cljs.core/fn?","tiltontec.cell.core/cI","seq29376","G__29377","cljs.core/first","cljs.core/next","self__4851__auto__","value","option-kvs","tiltontec.cell.core/cset!>","c","new-value","tiltontec.cell.base/*defer-changes*","cljs.core.println","tiltontec.cell.base/c-slot","cljs.core/some","tiltontec.cell.base/c-lazy","tiltontec.cell.evaluate/c-value-assume","tiltontec.cell.integrity/call-with-integrity","opcode","defer-info","tiltontec.cell.core/c-reset!","tiltontec.cell.core/cswap!>","seq29396","G__29397","G__29398","swap-fn","swap-fn-args","tiltontec.cell.evaluate/<cget","tiltontec.cell.core/call-c-reset-next!"],"sourcesContent":["(ns tiltontec.cell.core\n  (:require\n\n    [tiltontec.util.core :refer [rmap-setf]]\n    ;#?(:clj [taoensso.tufte :as tufte :refer :all]\n    ;   :cljs [taoensso.tufte :as tufte :refer-macros [defnp p profiled profile]])\n    #?(:cljs [tiltontec.util.base\n              :refer-macros [trx wtrx prog1 *trx?* def-rmap-slots def-rmap-meta-slots]]\n       :clj [tiltontec.util.base :refer :all])\n\n    #?(:clj [tiltontec.cell.base :refer :all :as cty]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [c-optimized-away? c-formula? c-value c-optimize\n                      c-unbound? c-input? unbound\n                      c-model mdead? c-valid? c-useds c-ref? md-ref?\n                      c-state +pulse+ c-pulse-observed\n                      *call-stack* *defer-changes*\n                      c-rule c-me c-value-state c-callers caller-ensure\n                      c-synapses\n                      unlink-from-callers *causation*\n                      c-synaptic? caller-drop\n                      c-pulse c-pulse-last-changed c-ephemeral? c-slot\n                      *depender* *not-to-be*\n                      *c-prop-depth* md-slot-owning? c-lazy] :as cty])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer :all]\n       :cljs [tiltontec.cell.observer\n              :refer-macros [fn-obs]\n              :refer []])\n\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    #?(:clj\n    [tiltontec.cell.integrity :refer :all]\n       :cljs [tiltontec.cell.integrity\n              :refer-macros [with-integrity]\n              :refer []])\n    [tiltontec.cell.evaluate :refer [c-get <cget c-value-assume\n                                     record-dependency ensure-value-is-current]]))\n\n;;#?(:cljs (set! *print-level* 3))\n\n; todo: stand-alone cells with observers should be observed when they are made\n\n(defn make-cell [& kvs]\n  (let [options (apply hash-map kvs)]\n    (#?(:clj ref :cljs atom) (merge {:value unbound\n                                     ::cty/state :nascent\n                                     :pulse 0\n                                     :pulse-last-changed 0\n                                     :pulse-observed 0\n                                     :callers #{}\n                                     :synapses #{}          ;; these stay around between evaluations\n                                     ;; todo: if a rule branches away from a synapse\n                                     ;;       it needs to be GCed so it starts fresh\n                                     :lazy false            ;; not a predicate (can hold, inter alia, :until-asked)\n                                     :ephemeral? false\n                                     :input? true}\n\n                              options)\n         :meta {:type :tiltontec.cell.base/cell})))\n\n(defn make-c-formula [& kvs]\n  (let [options (apply hash-map kvs)\n        rule (:rule options)]\n    (assert rule)\n    (assert (fn? rule))\n\n\n    (#?(:clj ref :cljs atom) (merge {:value unbound\n                                     ::cty/state :nascent   ;; s/b :unbound?\n                                     :pulse 0\n                                     :pulse-last-changed 0\n                                     :pulse-observed 0\n                                     :callers #{}\n                                     :useds #{}\n                                     :lazy false\n                                     :ephemeral? false\n                                     :optimize true         ;; this can also be :when-not-nil\n                                     :input? false}         ;; not redundant: can start with rule, continue as input\n\n                              options)\n         :meta {:type :tiltontec.cell.base/c-formula})))\n\n;;___________________ constructors _______________________________\n;; I seem to have created a zillion of these, but I normally\n;; use just cI, cF, and cFn (which starts out as cF and becomes cI).\n;; \n\n(defmacro c-fn-var [[c] & body]\n  `(fn [~c]\n     (let [~'me (c-model ~c)\n           ~'cell ~c\n           ~'slot-name (c-slot ~c)\n           ~'cache (c-value ~c)]\n      ~@body)))\n\n(defmacro c-fn [& body]\n  `(c-fn-var (~'slot-c#) ~@body))\n\n(defmacro cF [& body]\n  `(make-c-formula\n     :code '~body\n     :value unbound\n     :rule (c-fn ~@body)))\n\n(defmacro cF+ [[& options] & body]\n  `(make-c-formula\n     ~@options\n     :code '~body\n     :value unbound\n     :rule (c-fn ~@body)))\n\n(defmacro cFn [& body]\n  `(make-c-formula\n     :code '(without-c-dependency ~@body)\n     :input? true\n     :value unbound\n     :rule (c-fn (without-c-dependency ~@body))))\n\n(defmacro cF+n [[& options] & body]\n  `(make-c-formula\n     ~@options\n     :code '(without-c-dependency ~@body)\n     :input? true\n     :value unbound\n     :rule (c-fn (without-c-dependency ~@body))))\n\n(defmacro c_Fn [& body]\n  `(make-c-formula\n    :code '(without-c-dependency ~@body)\n    :input? true\n    :lazy :until-asked\n    :value unbound\n    :rule (c-fn (without-c-dependency ~@body))))\n\n(defmacro cFn-dbg [& body]\n  `(make-c-formula\n    :code '(without-c-dependency ~@body)\n    :input? true\n    :debug true\n    :value unbound\n    :rule (c-fn (without-c-dependency ~@body))))\n\n(defmacro cFn-until [args & body]\n  `(make-c-formula\n    :optimize :when-value-t\n    :code '~body\n    :input? true\n    :value unbound\n    :rule (c-fn ~@body)\n    ~@args))\n\n(defmacro cFonce [& body]\n  `(make-c-formula\n    :code '(without-c-dependency ~@body)\n    :input? nil\n    :value unbound\n    :rule (c-fn (without-c-dependency ~@body))))\n\n(defmacro c_1 [& body]\n  `(make-c-formula\n    :code '(without-c-dependency ~@body)\n    :input? nil\n    :lazy true\n    :value unbound\n    :rule (c-fn (without-c-dependency ~@body))))\n\n(defmacro cF1 [& body]\n  `(cFonce ~@body))\n\n(defmacro cFdbg [& body]\n  `(make-c-formula\n    :code '~body\n    :value unbound\n    :debug true\n    :rule (c-fn ~@body)))\n\n(defmacro cF_  [[& options] & body]\n  `(make-c-formula\n    ~@options\n    :code '~body\n    :value unbound\n    :lazy true\n    :rule (c-fn ~@body)))\n\n(defmacro c_F [[& options] & body]\n  \"Lazy until asked, then eagerly propagating\"\n  `(make-c-formula\n    ~@options\n    :code '~body\n    :value unbound\n    :lazy :until-asked\n    :rule (c-fn ~@body)))\n\n(defmacro c_Fdbg [& body]\n  \"Lazy until asked, then eagerly propagating\"\n  `(make-c-formula\n    :code '~body\n    :value unbound\n    :lazy :until-asked\n    :rule (c-fn ~@body)\n    :debug true))\n\n;; todo add validation somewhere of lazy option\n\n(defmacro c-formula [[& kvs] & body]\n  `(make-c-formula\n    :code '~body                                            ;; debug aid\n    :value unbound\n    :rule (c-fn ~@body)\n    ~@keys))\n\n(defn cI [value & option-kvs]\n  (apply make-cell\n         :value value\n         :input? true\n         option-kvs))\n\n;; --- where change and animation begin -------\n\n(defn cset!> [c new-value]\n  \"The moral equivalent of a Common Lisp SETF, and indeed\nin the CL version of Cells SETF itself is the change API dunction.\"\n  (assert c)\n  ;; (println :c-reset new-value)\n  (cond\n    *defer-changes*\n    (do (println :c-reset-rejecting-undeferred! (c-slot c))\n      #_ (throw (#?(:clj Exception. :cljs js/Error.)\n       (cl-format t \"c-reset!> change to ~s must be deferred by wrapping it in WITH-INTEGRITY\"\n                       (c-slot c)))))\n    ;-----------------------------------\n    (some #{(c-lazy c)} [:once-asked :always true])\n    (c-value-assume c new-value nil)\n    ;-------------------------------------------\n    :else\n    (do                                                     ;; tufte/p :wi-cvassume-sync\n     (#?(:clj dosync :cljs do)\n     (with-integrity (:change (c-slot c))\n         (c-value-assume c new-value nil))))))\n\n(defn c-reset! [c new-value]\n  (cset!> c new-value))\n\n(defn cswap!> [c swap-fn & swap-fn-args]\n  (cset!> c (apply swap-fn (<cget c) swap-fn-args)))\n\n\n(defmacro c-reset-next! [f-c f-new-value]\n  \"Observers should have side-effects only outside the\ncell-mediated model, but it can be useful to have an observer\nkick off further change to the model. To achieve this we\nallow an observer to explicitly queue a c-reset! for \nexecution as soon as the current change is manifested.\"\n  `(cond\n     (not *within-integrity*)\n     (throw (#?(:clj Exception. :cljs js/Error.) \"c-reset-next!> deferred change to %s not under WITH-INTEGRITY supervision.\"\n                        (c-slot ~f-c)))\n     ;---------------------------------------------\n     :else\n     (ufb-add :change\n              [:c-reset-next!\n               (fn [~'opcode ~'defer-info]\n                 (let [c# ~f-c\n                       new-value# ~f-new-value]\n                   (call-c-reset-next! c# new-value#)))])))\n\n(defmacro cset-next!>\n  \"Completely untested!!!!!!!!!!!!!!!\"\n  [f-c f-new-value]\n  `(c-reset-next! ~f-c ~f-new-value))\n\n\n(defn call-c-reset-next! [c new-value]\n  (cond\n    ;;-----------------------------------\n    (some #{(c-lazy c)} [:once-asked :always true])\n    (c-value-assume c new-value nil)\n    ;;-------------------------------------------\n    :else\n    (#?(:cljs do :clj dosync)\n     (c-value-assume c new-value nil))))\n\n\n"]}